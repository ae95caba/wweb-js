const axios = require("axios");

// Estado de conversaci√≥n por usuario
const userStates = {}; // { [userId]: { state: 'menu' | 'product' | 'ice-cream-flavour' | 'human_support', selectedProductId, ... } }

// Usuarios que est√°n hablando con una persona real (bot desactivado)
const usersWithHumanSupport = new Set();

// Helper: number to emoji, usando un emoji por cada d√≠gito
function numberToEmoji(n) {
  const emojiMap = ["0Ô∏è‚É£", "1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£"];
  return n
    .toString()
    .split("")
    .map((digit) => emojiMap[parseInt(digit, 10)])
    .join("");
}

// Funci√≥n para mostrar el men√∫ principal din√°mico
async function getMainMenu() {
  try {
    const { data: products } = await axios.get(
      "http://localhost:3000/products"
    );
    // Filtrar productos disponibles
    const availableProducts = products.filter((p) => !p.outOfStock);
    let menu = `ü§ñ *Bienvenido al Bot*\n\nPor favor, selecciona un producto o una opci√≥n:\n\n`;
    availableProducts.forEach((p, i) => {
      menu += `${numberToEmoji(i + 1)} *${p.name.toUpperCase()}* - $${
        p.price
      }\n`;
    });
    menu += `\n${numberToEmoji(
      availableProducts.length + 1
    )} *üí¨ Hablar con una persona real*`;
    menu += `\n${numberToEmoji(availableProducts.length + 2)} *Salir*`;
    menu += `\n\nResponde con el n√∫mero de la opci√≥n (1-${
      availableProducts.length + 2
    })`;
    return { menu, availableProducts };
  } catch (e) {
    return {
      menu: "‚ùå Error al obtener los productos. Intenta m√°s tarde.",
      availableProducts: [],
    };
  }
}

// Funci√≥n para mostrar men√∫ de sabores de helado
async function getFlavourMenu() {
  try {
    const { data: flavours } = await axios.get(
      "http://localhost:3000/generic/flavour"
    );
    const availableFlavours = flavours.filter((f) => !f.outOfStock);
    let menu = `üç¶ *Elige un sabor de helado:*\n\n`;
    availableFlavours.forEach((f, i) => {
      menu += `${numberToEmoji(i + 1)} *${f.name}*\n`;
    });
    menu += `\nResponde con el n√∫mero de la opci√≥n (1-${availableFlavours.length})`;
    return { menu, availableFlavours };
  } catch (e) {
    return {
      menu: "‚ùå Error al obtener los sabores. Intenta m√°s tarde.",
      availableFlavours: [],
    };
  }
}

// Helper para mostrar el carrito
function renderCart(cart) {
  if (!cart || cart.length === 0) return "üõí *Tu carrito est√° vac√≠o.*";
  let msg = "üõí *Tu carrito actual:*\n";
  cart.forEach((item, i) => {
    msg += `${numberToEmoji(i + 1)} *${item.name.toUpperCase()}* - $${
      item.price
    }`;
    if (item.flavours && item.flavours.length > 0) {
      msg += `\n   Sabores: ${item.flavours.join(", ")}`;
    }
    msg += "\n";
  });
  return msg;
}

// Funci√≥n principal para manejar mensajes del bot
async function handleBotMessage(message) {
  const userId = message.from;
  const userMessage = message.body ? message.body.toLowerCase().trim() : "";

  // Inicializar estado del usuario si no existe
  if (!userStates[userId]) {
    userStates[userId] = { state: "menu" };
  }
  // Inicializar carrito si no existe
  if (!userStates[userId].cart) userStates[userId].cart = [];

  // Si el usuario est√° en modo persona real, no responder
  if (usersWithHumanSupport.has(userId)) return;

  // LOG: Estado actual y mensaje recibido
  console.log(
    `[BOT] Estado actual: ${userStates[userId].state}, Mensaje: '${userMessage}'`
  );

  // Mostrar men√∫ principal si el usuario escribe "menu", "hola" o "inicio"
  if (["menu", "hola", "inicio"].includes(userMessage)) {
    userStates[userId] = { state: "menu" };
    const { menu, availableProducts } = await getMainMenu();
    userStates[userId].availableProducts = availableProducts;
    console.log(`[BOT] Transici√≥n a estado: menu`);
    return menu;
  }

  // Men√∫ principal din√°mico
  if (userStates[userId].state === "menu") {
    const availableProducts = userStates[userId].availableProducts;
    if (!availableProducts) {
      const { menu, availableProducts: products } = await getMainMenu();
      userStates[userId].availableProducts = products;
      console.log(`[BOT] Sin productos en estado, mostrando men√∫ principal`);
      return menu;
    }
    const option = parseInt(userMessage, 10);
    if (isNaN(option) || option < 1 || option > availableProducts.length + 2) {
      const { menu } = await getMainMenu();
      console.log(`[BOT] Opci√≥n inv√°lida en men√∫ principal`);
      return `‚ùå Por favor, selecciona una opci√≥n v√°lida.\n\n${menu}`;
    }
    if (option === availableProducts.length + 1) {
      usersWithHumanSupport.add(userId);
      userStates[userId] = { state: "human_support" };
      console.log(`[BOT] Transici√≥n a estado: human_support`);
      return `üë®‚Äçüíº *Conectando con una persona real...*\n\n‚úÖ *Bot desactivado para esta conversaci√≥n*\n\nUn representante se pondr√° en contacto contigo pronto. Mientras tanto, puedes escribir libremente y ser√°s atendido por una persona real.`;
    }
    if (option === availableProducts.length + 2) {
      userStates[userId] = { state: "menu" };
      console.log(`[BOT] Transici√≥n a estado: menu (salir)`);
      return `üëã *¬°Hasta luego!*\n\nGracias por usar nuestro bot. ¬°Que tengas un excelente d√≠a!\n\nPara volver a empezar, escribe "hola" o "menu"`;
    }
    const selectedProduct = availableProducts[option - 1];
    userStates[userId].selectedProductId = selectedProduct._id;
    // Mostrar confirmaci√≥n del producto
    userStates[userId].state = "confirm-product";
    console.log(`[BOT] Transici√≥n a estado: confirm-product`);
    return `üç∞ *${selectedProduct.name.toUpperCase()}*\n\n${
      selectedProduct.description ? selectedProduct.description + "\n" : ""
    }üí≤Precio: $${
      selectedProduct.price
    }\n\n¬øConfirmas este producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
  }

  // Confirmaci√≥n de producto seleccionado
  if (userStates[userId].state === "confirm-product") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      const availableProducts = userStates[userId].availableProducts;
      const selectedProduct = availableProducts.find(
        (p) => p._id === userStates[userId].selectedProductId
      );
      if (selectedProduct.type === "ice-cream") {
        userStates[userId].state = "ice-cream-flavour";
        userStates[userId].maxFlavours = selectedProduct.flavours || 1;
        const { menu, availableFlavours } = await getFlavourMenu();
        userStates[userId].availableFlavours = availableFlavours;
        console.log(
          `[BOT] Transici√≥n a estado: ice-cream-flavour (maxFlavours: ${userStates[userId].maxFlavours})`
        );
        return (
          menu +
          `\n\n*Puedes elegir hasta ${userStates[userId].maxFlavours} sabores. Ejemplo: 1 3 5*`
        );
      } else {
        // Agregar producto al carrito directamente
        userStates[userId].cart.push({
          name: selectedProduct.name,
          price: selectedProduct.price,
          _id: selectedProduct._id,
        });
        userStates[userId].state = "show-product-info";
        console.log(`[BOT] Transici√≥n a estado: show-product-info`);
        return `${renderCart(
          userStates[userId].cart
        )}\n\n¬øQuieres agregar otro producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
      }
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "menu";
      const { menu, availableProducts: newProducts } = await getMainMenu();
      userStates[userId].availableProducts = newProducts;
      console.log(`[BOT] Transici√≥n a estado: menu (producto no confirmado)`);
      return menu;
    } else {
      const availableProducts = userStates[userId].availableProducts;
      const selectedProduct = availableProducts.find(
        (p) => p._id === userStates[userId].selectedProductId
      );
      console.log(`[BOT] Respuesta inv√°lida en confirm-product`);
      return `Por favor responde con 1 (s√≠) o 2 (no).\n\nüç∞ *${selectedProduct.name.toUpperCase()}*\n\n${
        selectedProduct.description ? selectedProduct.description + "\n" : ""
      }üí≤Precio: $${
        selectedProduct.price
      }\n\n¬øConfirmas este producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // Men√∫ de sabores de helado (selecci√≥n m√∫ltiple y confirmaci√≥n)
  if (userStates[userId].state === "ice-cream-flavour") {
    const availableFlavours = userStates[userId].availableFlavours;
    const maxFlavours = userStates[userId].maxFlavours || 1;
    const selectedOptions = userMessage
      .split(/[\,\s]+/)
      .map((x) => parseInt(x, 10))
      .filter((x) => !isNaN(x));
    if (
      !availableFlavours ||
      selectedOptions.length === 0 ||
      selectedOptions.some(
        (opt) => opt < 1 || opt > availableFlavours.length
      ) ||
      selectedOptions.length > maxFlavours
    ) {
      const { menu } = await getFlavourMenu();
      console.log(`[BOT] Selecci√≥n de sabores inv√°lida`);
      return `‚ùå Por favor, selecciona hasta ${maxFlavours} sabores v√°lidos.\n\n${menu}\n\n*Ejemplo: 1 3 5*`;
    }
    userStates[userId].pendingFlavours = selectedOptions;
    const selectedFlavours = selectedOptions.map(
      (opt) => availableFlavours[opt - 1].name
    );
    userStates[userId].state = "confirm-flavours";
    console.log(
      `[BOT] Transici√≥n a estado: confirm-flavours (sabores: ${selectedFlavours.join(
        ", "
      )})`
    );
    return `üç¶ *Los sabores que elegiste son:* ${selectedFlavours.join(
      ", "
    )}\n\n¬øEs correcto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
  }

  // Confirmaci√≥n de sabores
  if (userStates[userId].state === "confirm-flavours") {
    const availableFlavours = userStates[userId].availableFlavours;
    const maxFlavours = userStates[userId].maxFlavours || 1;
    const selectedOptions = userStates[userId].pendingFlavours || [];
    const selectedFlavours = selectedOptions.map(
      (opt) => availableFlavours[opt - 1].name
    );
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      if (selectedOptions.length < maxFlavours) {
        userStates[userId].state = "add-more-flavour";
        console.log(`[BOT] Transici√≥n a estado: add-more-flavour`);
        return `A√∫n puedes elegir un sabor m√°s, ¬øquieres hacerlo?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
      } else {
        // Agregar producto con sabores al carrito inmediatamente
        const availableProducts = userStates[userId].availableProducts;
        const selectedProduct = availableProducts.find(
          (p) => p._id === userStates[userId].selectedProductId
        );
        if (selectedProduct) {
          userStates[userId].cart.push({
            name: selectedProduct.name,
            price: selectedProduct.price,
            _id: selectedProduct._id,
            flavours: selectedFlavours,
          });
        }
        userStates[userId].state = "show-flavour-confirmation";
        console.log(
          `[BOT] Transici√≥n a estado: show-flavour-confirmation (sabores confirmados)`
        );
        return `${renderCart(
          userStates[userId].cart
        )}\n\n¬øQuieres agregar otro producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
      }
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "ice-cream-flavour";
      console.log(
        `[BOT] Transici√≥n a estado: ice-cream-flavour (repetir selecci√≥n)`
      );
      return await getFlavourMenu().then(
        ({ menu }) =>
          menu +
          `\n\n*Puedes elegir hasta ${maxFlavours} sabores. Ejemplo: 1 3 5*`
      );
    } else {
      console.log(`[BOT] Respuesta inv√°lida en confirm-flavours`);
      return `Por favor responde con 1 (s√≠) o 2 (no).\n\nüç¶ *Los sabores que elegiste son:* ${selectedFlavours.join(
        ", "
      )}\n\n¬øEs correcto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // ¬øAgregar m√°s sabores?
  if (userStates[userId].state === "add-more-flavour") {
    const availableFlavours = userStates[userId].availableFlavours;
    const maxFlavours = userStates[userId].maxFlavours || 1;
    const selectedOptions = userStates[userId].pendingFlavours || [];
    const selectedFlavours = selectedOptions.map(
      (opt) => availableFlavours[opt - 1].name
    );
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      const remaining = maxFlavours - selectedOptions.length;
      const remainingFlavours = availableFlavours
        .map((f, i) => ({ ...f, idx: i + 1 }))
        .filter((f) => !selectedOptions.includes(f.idx));
      if (remainingFlavours.length === 0) {
        // Agregar producto con sabores al carrito inmediatamente
        const availableProducts = userStates[userId].availableProducts;
        const selectedProduct = availableProducts.find(
          (p) => p._id === userStates[userId].selectedProductId
        );
        if (selectedProduct) {
          userStates[userId].cart.push({
            name: selectedProduct.name,
            price: selectedProduct.price,
            _id: selectedProduct._id,
            flavours: selectedFlavours,
          });
        }
        userStates[userId].state = "show-flavour-confirmation";
        console.log(
          `[BOT] No quedan m√°s sabores, transici√≥n a show-flavour-confirmation`
        );
        return `${renderCart(
          userStates[userId].cart
        )}\n\n¬øQuieres agregar otro producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
      }
      userStates[userId].state = "add-flavour-selection";
      userStates[userId].remainingFlavours = remainingFlavours;
      userStates[userId].remainingCount = remaining;
      let menu = `üç¶ *Elige ${remaining} sabor(es) m√°s:*\n\n`;
      remainingFlavours.forEach((f, i) => {
        menu += `${numberToEmoji(i + 1)} *${f.name}*\n`;
      });
      menu += `\nResponde con el n√∫mero de la opci√≥n.`;
      console.log(`[BOT] Transici√≥n a estado: add-flavour-selection`);
      return menu;
    } else if (userMessage === "2" || userMessage === "no") {
      // Agregar producto con sabores al carrito inmediatamente
      const availableProducts = userStates[userId].availableProducts;
      const selectedProduct = availableProducts.find(
        (p) => p._id === userStates[userId].selectedProductId
      );
      if (selectedProduct) {
        userStates[userId].cart.push({
          name: selectedProduct.name,
          price: selectedProduct.price,
          _id: selectedProduct._id,
          flavours: selectedFlavours,
        });
      }
      userStates[userId].state = "show-flavour-confirmation";
      console.log(
        `[BOT] Transici√≥n a estado: show-flavour-confirmation (sabores confirmados)`
      );
      return `${renderCart(
        userStates[userId].cart
      )}\n\n¬øQuieres agregar otro producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en add-more-flavour`);
      return `Por favor responde con 1 (s√≠) o 2 (no).\n\nA√∫n puedes elegir un sabor m√°s, ¬øquieres hacerlo?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // Selecci√≥n de sabor adicional
  if (userStates[userId].state === "add-flavour-selection") {
    const remainingFlavours = userStates[userId].remainingFlavours || [];
    const remainingCount = userStates[userId].remainingCount || 1;
    const selectedOptions = userStates[userId].pendingFlavours || [];
    const opt = parseInt(userMessage, 10);
    if (isNaN(opt) || opt < 1 || opt > remainingFlavours.length) {
      let menu = `‚ùå Selecci√≥n inv√°lida.\n\nüç¶ *Elige ${remainingCount} sabor(es) m√°s:*\n\n`;
      remainingFlavours.forEach((f, i) => {
        menu += `${numberToEmoji(i + 1)} *${f.name}*\n`;
      });
      menu += `\nResponde con el n√∫mero de la opci√≥n.`;
      console.log(`[BOT] Selecci√≥n inv√°lida en add-flavour-selection`);
      return menu;
    }
    const newFlavourIdx = remainingFlavours[opt - 1].idx;
    selectedOptions.push(newFlavourIdx);
    userStates[userId].pendingFlavours = selectedOptions;
    const allFlavours = userStates[userId].availableFlavours;
    const selectedFlavours = selectedOptions.map(
      (idx) => allFlavours[idx - 1].name
    );
    userStates[userId].state = "confirm-flavours";
    console.log(
      `[BOT] Transici√≥n a estado: confirm-flavours (sabores: ${selectedFlavours.join(
        ", "
      )})`
    );
    return `üç¶ *Los sabores que elegiste son:* ${selectedFlavours.join(
      ", "
    )}\n\n¬øEs correcto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
  }

  // Despu√©s de mostrar descripci√≥n y precio de un producto (no helado)
  if (userStates[userId].state === "show-product-info") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      // Solo volver al men√∫ principal, el producto ya est√° en el carrito
      userStates[userId].state = "menu";
      const { menu, availableProducts: newProducts } = await getMainMenu();
      userStates[userId].availableProducts = newProducts;
      console.log(`[BOT] Transici√≥n a estado: menu (agregar otro producto)`);
      return menu;
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "delivery-option";
      console.log(
        `[BOT] Transici√≥n a estado: delivery-option (pedido finalizado)`
      );
      return `${renderCart(
        userStates[userId].cart
      )}\n\nüöö *¬øC√≥mo quieres recibir tu pedido?*\n\n1Ô∏è‚É£ üè† *Env√≠o a domicilio*\n2Ô∏è‚É£ üè™ *Retirar en el local*`;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en show-product-info`);
      return `${renderCart(
        userStates[userId].cart
      )}\n\n¬øQuieres agregar otro producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // Despu√©s de confirmar sabores de helado
  if (userStates[userId].state === "show-flavour-confirmation") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      userStates[userId].state = "menu";
      const { menu, availableProducts: newProducts } = await getMainMenu();
      userStates[userId].availableProducts = newProducts;
      console.log(
        `[BOT] Transici√≥n a estado: menu (agregar otro producto tras sabores)`
      );
      return menu;
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "delivery-option";
      console.log(
        `[BOT] Transici√≥n a estado: delivery-option (pedido finalizado tras sabores)`
      );
      return `${renderCart(
        userStates[userId].cart
      )}\n\nüöö *¬øC√≥mo quieres recibir tu pedido?*\n\n1Ô∏è‚É£ üè† *Env√≠o a domicilio*\n2Ô∏è‚É£ üè™ *Retirar en el local*`;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en show-flavour-confirmation`);
      return `${renderCart(
        userStates[userId].cart
      )}\n\n¬øQuieres agregar otro producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // Opci√≥n de entrega
  if (userStates[userId].state === "delivery-option") {
    if (
      userMessage === "1" ||
      userMessage === "env√≠o" ||
      userMessage === "domicilio"
    ) {
      userStates[userId].state = "ask-address";
      console.log(`[BOT] Transici√≥n a estado: ask-address`);
      return `üìç *Por favor, env√≠a tu direcci√≥n completa:*\n\nIncluye:\n‚Ä¢ Calle y n√∫mero\n‚Ä¢ Entre calles\n‚Ä¢ Barrio\n\nEjemplo: "Av. Corrientes 1234, entre Callao y Uruguay, Palermo"`;
    } else if (
      userMessage === "2" ||
      userMessage === "retirar" ||
      userMessage === "local"
    ) {
      userStates[userId].state = "pickup-confirmation";
      console.log(`[BOT] Transici√≥n a estado: pickup-confirmation`);
      return `üè™ *Retiro en local confirmado*\n\n${renderCart(
        userStates[userId].cart
      )}\n\nüìç *Direcci√≥n del local:*\nAv. Principal 123, Centro\nHorarios: Lunes a Domingo 9:00 - 22:00\n\n¬°Gracias por tu pedido! Te avisaremos cuando est√© listo para retirar.`;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en delivery-option`);
      return `‚ùå Por favor, selecciona una opci√≥n v√°lida.\n\nüöö *¬øC√≥mo quieres recibir tu pedido?*\n\n1Ô∏è‚É£ üè† *Env√≠o a domicilio*\n2Ô∏è‚É£ üè™ *Retirar en el local*`;
    }
  }

  // Solicitar direcci√≥n
  if (userStates[userId].state === "ask-address") {
    if (userMessage && userMessage.length > 10) {
      userStates[userId].deliveryAddress = userMessage;
      userStates[userId].state = "address-confirmation";
      console.log(`[BOT] Transici√≥n a estado: address-confirmation`);
      return `üìç *Direcci√≥n confirmada:*\n${userMessage}\n\n${renderCart(
        userStates[userId].cart
      )}\n\n¬øEs correcta la direcci√≥n?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No (escribir de nuevo)`;
    } else {
      console.log(`[BOT] Direcci√≥n muy corta en ask-address`);
      return `‚ùå Por favor, env√≠a una direcci√≥n m√°s completa.\n\nIncluye:\n‚Ä¢ Calle y n√∫mero\n‚Ä¢ Entre calles\n‚Ä¢ Barrio\n\nEjemplo: "Av. Corrientes 1234, entre Callao y Uruguay, Palermo"`;
    }
  }

  // Confirmar direcci√≥n
  if (userStates[userId].state === "address-confirmation") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      userStates[userId].state = "order-complete";
      console.log(`[BOT] Transici√≥n a estado: order-complete`);
      return `‚úÖ *¬°Pedido confirmado!*\n\n${renderCart(
        userStates[userId].cart
      )}\n\nüìç *Direcci√≥n de entrega:*\n${
        userStates[userId].deliveryAddress
      }\n\nüöö Tu pedido ser√° entregado en aproximadamente 30-45 minutos.\n\n¬°Gracias por tu compra! Si quieres hacer otro pedido, escribe "menu".`;
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "ask-address";
      console.log(
        `[BOT] Transici√≥n a estado: ask-address (direcci√≥n incorrecta)`
      );
      return `üìç *Por favor, env√≠a tu direcci√≥n completa nuevamente:*\n\nIncluye:\n‚Ä¢ Calle y n√∫mero\n‚Ä¢ Entre calles\n‚Ä¢ Barrio\n\nEjemplo: "Av. Corrientes 1234, entre Callao y Uruguay, Palermo"`;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en address-confirmation`);
      return `‚ùå Por favor, responde con 1 (s√≠) o 2 (no).\n\nüìç *Direcci√≥n confirmada:*\n${userStates[userId].deliveryAddress}\n\n¬øEs correcta la direcci√≥n?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No (escribir de nuevo)`;
    }
  }

  // Confirmar retiro en local
  if (userStates[userId].state === "pickup-confirmation") {
    userStates[userId].state = "order-complete";
    console.log(`[BOT] Transici√≥n a estado: order-complete (retiro)`);
    return `‚úÖ *¬°Pedido confirmado para retiro!*\n\n${renderCart(
      userStates[userId].cart
    )}\n\nüè™ *Retiro en local*\nüìç Av. Principal 123, Centro\nHorarios: Lunes a Domingo 9:00 - 22:00\n\n‚è∞ Tu pedido estar√° listo en aproximadamente 15-20 minutos.\n\n¬°Gracias por tu compra! Si quieres hacer otro pedido, escribe "menu".`;
  }

  // Si no hay respuesta v√°lida
  const { menu } = await getMainMenu();
  console.log(
    `[BOT] Comando no reconocido, estado: ${userStates[userId].state}`
  );
  return `‚ùå Comando no reconocido. Escribe "menu" para volver al men√∫ principal.\n\n${menu}`;
}

async function shouldIgnoreMessage(message) {
  let name;
  let log;
  const isFromMe = message._data.id.fromMe;
  const targetNumber = "5491130350056@c.us"; // The number you don't want to forward messages to/from

  const hasImage = message.type === "image";

  const chat = await message.getChat();
  // Check if the chat is archived
  const isArchived = chat.archived;
  // Ignore status updates (WhatsApp Stories)
  const isStory = message.from === "status@broadcast";
  const isSticker = message.type === "sticker";
  const isVoiceMessage = message.type === "ptt";
  console.log("message type is: ");
  console.log(message.type);
  const isTextLess = !message.body || message.body === "";

  //ignore group messages
  const isGroupChat = chat.id.server === "g.us";
  //ignore muted chats
  const isMuted = chat.muteExpiration === -1;
  // Skip empty or "This message can't be displayed here" messages
  const isEmpty = !hasImage && isTextLess && !isVoiceMessage && !isSticker;
  // Ignore messages sent to or received from the target number
  const isIrrelevant =
    message.from === targetNumber || message.to === targetNumber;

  // Ignore messages from users who are talking to a human
  const isUserWithHumanSupport = usersWithHumanSupport.has(message.from);

  const reasonsToIgnoreMessage = [];

  if (isGroupChat) reasonsToIgnoreMessage.push("isGroupChat");
  if (isArchived) reasonsToIgnoreMessage.push("isArchived");
  if (isStory) reasonsToIgnoreMessage.push("isStory");

  /* if (isIrrelevant) reasonsToIgnoreMessage.push("isIrrelevant"); */
  if (isMuted) reasonsToIgnoreMessage.push("isMuted");
  if (isEmpty) reasonsToIgnoreMessage.push("isEmpty");
  if (isUserWithHumanSupport)
    reasonsToIgnoreMessage.push("isUserWithHumanSupport");

  if (reasonsToIgnoreMessage.length > 0) {
    console.log("--------------- START -------------------");
    console.log("return triggered");
    console.log("reason:", reasonsToIgnoreMessage.join(", "));
    console.log("--------------- END -------------------");
    return reasonsToIgnoreMessage.length;
  }
}

// Funci√≥n para obtener estad√≠sticas de usuarios
function getBotStats() {
  return {
    totalUsers: Object.keys(userStates).length,
    usersWithHumanSupport: usersWithHumanSupport.size,
    activeBotUsers: Object.keys(userStates).length - usersWithHumanSupport.size,
  };
}

module.exports = {
  shouldIgnoreMessage,
  handleBotMessage,
  getBotStats,
  usersWithHumanSupport,
};
