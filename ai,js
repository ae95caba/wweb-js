const axios = require("axios");

// Estado de conversaci√≥n por usuario
const userStates = {}; // { [userId]: { state: 'menu' | 'product' | 'ice-cream-flavour' | 'human_support', selectedProductId, ... } }

// Usuarios que est√°n hablando con una persona real (bot desactivado)
const usersWithHumanSupport = new Set();

// Funci√≥n para verificar si estamos en horario de atenci√≥n
function isBusinessHours() {
  const now = new Date();
  const currentHour = now.getHours();
  const currentDay = now.getDay(); // 0 = Domingo, 1 = Lunes, ..., 6 = S√°bado

  // Horarios de atenci√≥n:
  // Lunes a Viernes: 20:00 - 24:00
  // S√°bados, Domingos y Feriados: 13:00 - 01:00 del d√≠a siguiente

  const isWeekday = currentDay >= 1 && currentDay <= 5; // Lunes a Viernes
  const isWeekend = currentDay === 0 || currentDay === 6; // Domingo o S√°bado

  if (isWeekday) {
    // Lunes a Viernes: 20:00 - 24:00
    return currentHour >= 20 && currentHour < 24;
  } else if (isWeekend) {
    // S√°bados y Domingos: 13:00 - 01:00 del d√≠a siguiente
    return currentHour >= 13 || currentHour < 1;
  }

  return false;
}

// Funci√≥n para obtener el mensaje de horarios
function getBusinessHoursMessage() {
  return "üïê *Horarios de atenci√≥n:*\nLunes a Viernes: 20:00 - 24:00\nS√°bados, Domingos y Feriados: 13:00 - 01:00";
}

// Funci√≥n para obtener mensaje de fuera de horario
function getOutOfHoursMessage() {
  return "‚ùå *Lo sentimos, estamos cerrados*\n\nüïê *Horarios de atenci√≥n:*\nLunes a Viernes: 20:00 - 24:00\nS√°bados, Domingos y Feriados: 13:00 - 01:00\n\nPor favor, vuelve a intentar durante nuestro horario de atenci√≥n.";
}

// Helper: number to emoji, usando un emoji por cada d√≠gito
function numberToEmoji(n) {
  const emojiMap = ["0Ô∏è‚É£", "1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£"];
  return n
    .toString()
    .split("")
    .map((digit) => emojiMap[parseInt(digit, 10)])
    .join("");
}

// Funci√≥n para mostrar el men√∫ principal din√°mico
async function getMainMenu() {
  try {
    const { data: products } = await axios.get(
      "http://localhost:3000/products"
    );
    // Filtrar productos disponibles y excluir add-ons (se seleccionan en el submen√∫)
    const availableProducts = products.filter(
      (p) => !p.outOfStock && p.type !== "add-on"
    );
    let menu = `ü§ñ *Bienvenido al Bot*\n\n${getBusinessHoursMessage()}\n\nPor favor, selecciona un producto o una opci√≥n:\n\n`;
    availableProducts.forEach((p, i) => {
      menu += `${numberToEmoji(i + 1)} *${p.name.toUpperCase()}* - $${
        p.price
      }\n`;
    });
    menu += `\n${numberToEmoji(
      availableProducts.length + 1
    )} *üí¨ Hablar con una persona real*`;
    menu += `\n${numberToEmoji(availableProducts.length + 2)} *Salir*`;
    menu += `\n\nResponde con el n√∫mero de la opci√≥n (1-${
      availableProducts.length + 2
    })`;
    return { menu, availableProducts };
  } catch (e) {
    return {
      menu: "‚ùå Error al obtener los productos. Intenta m√°s tarde.",
      availableProducts: [],
    };
  }
}

// Funci√≥n para mostrar men√∫ de sabores de helado
async function getFlavourMenu() {
  try {
    const { data: flavours } = await axios.get(
      "http://localhost:3000/generic/flavour"
    );
    const availableFlavours = flavours.filter((f) => !f.outOfStock);
    let menu = `üç¶ *Elige los sabores de helado:*\n\n`;
    availableFlavours.forEach((f, i) => {
      menu += `${numberToEmoji(i + 1)} *${f.name}*\n`;
    });
    menu += `\nüí° *Puedes elegir m√∫ltiples sabores de una vez*\n`;
    menu += `üìù *Ejemplos:*\n`;
    menu += `‚Ä¢ Para elegir solo Vainilla: *1*\n`;
    menu += `‚Ä¢ Para elegir Vainilla y Chocolate: *1 2*\n`;
    menu += `‚Ä¢ Para elegir Vainilla, Chocolate y Frutilla: *1 2 3*\n`;

    return { menu, availableFlavours };
  } catch (e) {
    return {
      menu: "‚ùå Error al obtener los sabores. Intenta m√°s tarde.",
      availableFlavours: [],
    };
  }
}

// Funci√≥n para mostrar men√∫ de add-ons
async function getAddOnsMenu() {
  try {
    const { data: products } = await axios.get(
      "http://localhost:3000/products"
    );
    const addOns = products.filter((p) => p.type === "add-on" && !p.outOfStock);
    let menu = `üç´ *¬øQuieres agregar alg√∫n topping o complemento?*\n\n`;
    addOns.forEach((addon, i) => {
      menu += `${numberToEmoji(i + 1)} *${addon.name.toUpperCase()}* - $${
        addon.price
      }\n`;
    });
    menu += `\n${numberToEmoji(addOns.length + 1)} *No, gracias*\n`;
    menu += `\nResponde con el n√∫mero de la opci√≥n (1-${addOns.length + 1})`;
    return { menu, addOns };
  } catch (e) {
    return {
      menu: "‚ùå Error al obtener los add-ons. Intenta m√°s tarde.",
      addOns: [],
    };
  }
}

// Funci√≥n para mostrar men√∫ de sabores de salsa
async function getSauceFlavourMenu() {
  try {
    const { data: sauces } = await axios.get(
      "http://localhost:3000/generic/sauce"
    );
    const availableSauces = sauces.filter((s) => !s.outOfStock);
    let menu = `üçØ *Elige un sabor de salsa:*\n\n`;
    availableSauces.forEach((s, i) => {
      menu += `${numberToEmoji(i + 1)} *${s.name}*\n`;
    });
    menu += `\nResponde con el n√∫mero de la opci√≥n (1-${availableSauces.length})`;
    return { menu, availableSauces };
  } catch (e) {
    return {
      menu: "‚ùå Error al obtener los sabores de salsa. Intenta m√°s tarde.",
      availableSauces: [],
    };
  }
}

// Helper para mostrar el carrito
function renderCart(cart) {
  if (!cart || cart.length === 0) return "üõí *Tu carrito est√° vac√≠o.*";

  let msg = "üõí *Tu carrito actual:*\n";
  let totalGeneral = 0;

  cart.forEach((item, i) => {
    const price = item["totalPrice"] || item.price;
    const precioBase = item.price;
    totalGeneral += price;

    msg += `${numberToEmoji(i + 1)} *${item.name.toUpperCase()}*\n`;
    msg += `   üí≤Precio base: $${precioBase}`;

    if (item.flavours && item.flavours.length > 0) {
      msg += `\n   üç¶ Sabores: ${item.flavours.join(", ")}`;
    }

    if (item["addOns"] && item["addOns"].length > 0) {
      msg += `\n   üç´ Add-ons:`;
      // Mostrar detalles de cada add-on
      const addOnsArr = item["addOns"];
      const addOnsData = item.selectedAddOnsData || [];
      addOnsArr.forEach((name, idx) => {
        // Buscar si hay info de cantidad y sabor de salsa
        const data = addOnsData.find(
          (a) => a && (a.name === name || a.displayName === name)
        );
        if (data) {
          let addOnDisplay = `\n     - ${name}`;
          if (data.sauceFlavour) {
            addOnDisplay += ` (${data.sauceFlavour})`;
          }
          if (data.quantity && data.quantity > 1) {
            addOnDisplay += ` x${data.quantity} ($${data.price}) = $${
              data.price * data.quantity
            }`;
          } else {
            addOnDisplay += ` ($${data.price})`;
          }
          msg += addOnDisplay;
        } else {
          msg += `\n     - ${name}`;
        }
      });

      if (item["addOnsPrice"] && item["addOnsPrice"] > 0) {
        msg += `\n   üí≤Total add-ons: +$${item["addOnsPrice"]}`;
      }
    }

    if (item["totalPrice"] && item["totalPrice"] !== item.price) {
      msg += `\n   üí≤Total item: $${item["totalPrice"]}`;
    }

    msg += "\n";
  });

  msg += `\nüí∞ *TOTAL GENERAL: $${totalGeneral}*`;
  return msg;
}

// Funci√≥n para mostrar confirmaci√≥n final del helado con add-ons
async function showIceCreamConfirmation(userId) {
  const availableProducts = userStates[userId].availableProducts;
  const selectedProduct = availableProducts.find(
    (p) => p._id === userStates[userId].selectedProductId
  );
  const confirmedFlavours = userStates[userId].confirmedFlavours || [];
  const selectedAddOns = userStates[userId].selectedAddOns || [];

  // Crear el item del carrito
  const cartItem = {
    name: selectedProduct.name,
    price: selectedProduct.price,
    _id: selectedProduct._id,
    flavours: confirmedFlavours,
  };

  // Agregar add-ons si existen
  if (selectedAddOns.length > 0) {
    cartItem["addOns"] = selectedAddOns.map((a) => {
      // Si tiene sabor de salsa, usar el displayName, sino usar el nombre normal
      return a.displayName || a.name;
    });
    cartItem["addOnsPrice"] = selectedAddOns.reduce(
      (sum, a) => sum + a.price * (a.quantity || 1),
      0
    );
    cartItem["totalPrice"] = selectedProduct.price + cartItem["addOnsPrice"];
    cartItem["selectedAddOnsData"] = selectedAddOns.map((a) => {
      // Asegurar que se guarde toda la informaci√≥n del add-on incluyendo precio
      return {
        name: a.displayName || a.name,
        price: a.price,
        quantity: a.quantity || 1,
        sauceFlavour: a.sauceFlavour,
        _id: a._id,
      };
    });
  }

  userStates[userId].cart.push(cartItem);
  userStates[userId].state = "show-flavour-confirmation";
  // Limpiar add-ons seleccionados para el pr√≥ximo producto
  userStates[userId].selectedAddOns = [];

  return `${renderCart(
    userStates[userId].cart
  )}\n\n¬øQuieres agregar otro producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
}

// Funci√≥n principal para manejar mensajes del bot
async function handleBotMessage(message) {
  const userId = message.from;
  const userMessage = message.body ? message.body.toLowerCase().trim() : "";

  // Inicializar estado del usuario si no existe
  if (!userStates[userId]) {
    userStates[userId] = { state: "menu" };
  }
  // Inicializar carrito si no existe
  if (!userStates[userId].cart) userStates[userId].cart = [];

  // Verificar si el usuario est√° usando comandos de testing
  if (userMessage === "test_horario_on") {
    userStates[userId].testMode = true;
    console.log(`[BOT] Usuario ${userId} activ√≥ modo test`);
    return `‚úÖ *Modo test activado*\n\nüïê Verificaci√≥n de horarios desactivada\n\nPuedes usar el bot normalmente sin restricciones de horario.\n\nPara desactivar el modo test, escribe "test_horario_off"`;
  }

  if (userMessage === "test_horario_off") {
    userStates[userId].testMode = false;
    console.log(`[BOT] Usuario ${userId} desactiv√≥ modo test`);
    console.log(`[BOT] Estado actual del usuario:`, userStates[userId]);
    return `‚ùå *Modo test desactivado*\n\nüïê Verificaci√≥n de horarios reactivada\n\nAhora el bot respetar√° los horarios de atenci√≥n normales.\n\nEstado actual: testMode = ${userStates[userId].testMode}`;
  }

  // Verificar horarios de atenci√≥n al inicio (excepto si est√° en modo test)
  if (!userStates[userId].testMode && !isBusinessHours()) {
    console.log(
      `[BOT] Usuario ${userId} intent√≥ hacer un pedido fuera de horario`
    );
    console.log(
      `[BOT] testMode: ${
        userStates[userId].testMode
      }, isBusinessHours: ${isBusinessHours()}`
    );
    return getOutOfHoursMessage();
  }

  // Si el usuario est√° en modo persona real, no responder
  if (usersWithHumanSupport.has(userId)) return;

  // LOG: Estado actual y mensaje recibido
  console.log(
    `[BOT] Estado actual: ${userStates[userId].state}, Mensaje: '${userMessage}'`
  );

  // Mostrar men√∫ principal si el usuario escribe "menu", "hola" o "inicio"
  if (["menu", "hola", "inicio"].includes(userMessage)) {
    userStates[userId] = {
      state: "menu",
      testMode: userStates[userId].testMode,
    };
    const { menu, availableProducts } = await getMainMenu();
    userStates[userId].availableProducts = availableProducts;
    console.log(`[BOT] Transici√≥n a estado: menu`);
    return menu;
  }

  // Men√∫ principal din√°mico
  if (userStates[userId].state === "menu") {
    console.log(`[BOT] Procesando men√∫ principal, mensaje: '${userMessage}'`);
    const availableProducts = userStates[userId].availableProducts;
    console.log(
      `[BOT] Productos disponibles:`,
      availableProducts ? availableProducts.length : "undefined"
    );

    if (!availableProducts) {
      const { menu, availableProducts: products } = await getMainMenu();
      userStates[userId].availableProducts = products;
      console.log(`[BOT] Sin productos en estado, mostrando men√∫ principal`);
      return menu;
    }

    const option = parseInt(userMessage, 10);
    console.log(`[BOT] Opci√≥n parseada: ${option}, esNaN: ${isNaN(option)}`);
    console.log(`[BOT] Rango v√°lido: 1 a ${availableProducts.length + 2}`);

    if (isNaN(option) || option < 1 || option > availableProducts.length + 2) {
      const { menu } = await getMainMenu();
      console.log(`[BOT] Opci√≥n inv√°lida en men√∫ principal: ${option}`);
      return `‚ùå Por favor, selecciona una opci√≥n v√°lida.\n\n${menu}`;
    }

    console.log(`[BOT] Opci√≥n v√°lida seleccionada: ${option}`);

    if (option === availableProducts.length + 1) {
      usersWithHumanSupport.add(userId);
      userStates[userId] = {
        state: "human_support",
        testMode: userStates[userId].testMode,
      };
      console.log(`[BOT] Transici√≥n a estado: human_support`);
      return `üë®‚Äçüíº *Conectando con una persona real...*\n\n‚úÖ *Bot desactivado para esta conversaci√≥n*\n\nUn representante se pondr√° en contacto contigo pronto. Mientras tanto, puedes escribir libremente y ser√°s atendido por una persona real.`;
    }
    if (option === availableProducts.length + 2) {
      userStates[userId] = {
        state: "menu",
        testMode: userStates[userId].testMode,
      };
      console.log(`[BOT] Transici√≥n a estado: menu (salir)`);
      return `üëã *¬°Hasta luego!*\n\nGracias por usar nuestro bot. ¬°Que tengas un excelente d√≠a!\n\nPara volver a empezar, escribe "hola" o "menu"`;
    }

    const selectedProduct = availableProducts[option - 1];
    console.log(`[BOT] Producto seleccionado:`, selectedProduct);
    userStates[userId].selectedProductId = selectedProduct._id;
    // Mostrar confirmaci√≥n del producto
    userStates[userId].state = "confirm-product";
    console.log(`[BOT] Transici√≥n a estado: confirm-product`);
    return `üç∞ *${selectedProduct.name.toUpperCase()}*\n\n${
      selectedProduct.description ? selectedProduct.description + "\n" : ""
    }üí≤Precio: $${
      selectedProduct.price
    }\n\n¬øConfirmas este producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
  }

  // Confirmaci√≥n de producto seleccionado
  if (userStates[userId].state === "confirm-product") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      const availableProducts = userStates[userId].availableProducts;
      const selectedProduct = availableProducts.find(
        (p) => p._id === userStates[userId].selectedProductId
      );
      if (selectedProduct.type === "ice-cream") {
        userStates[userId].state = "ice-cream-flavour";
        userStates[userId].maxFlavours = selectedProduct.flavours || 1;
        const { menu, availableFlavours } = await getFlavourMenu();
        userStates[userId].availableFlavours = availableFlavours;
        console.log(
          `[BOT] Transici√≥n a estado: ice-cream-flavour (maxFlavours: ${userStates[userId].maxFlavours})`
        );
        return menu;
      } else {
        // Agregar producto al carrito directamente
        userStates[userId].cart.push({
          name: selectedProduct.name,
          price: selectedProduct.price,
          _id: selectedProduct._id,
        });
        userStates[userId].state = "show-product-info";
        console.log(`[BOT] Transici√≥n a estado: show-product-info`);
        return `${renderCart(
          userStates[userId].cart
        )}\n\n¬øQuieres agregar otro producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
      }
    } else if (userMessage === "2" || userMessage === "no") {
      // Preservar el carrito y solo cambiar el estado
      userStates[userId].state = "menu";
      const { menu, availableProducts: newProducts } = await getMainMenu();
      userStates[userId].availableProducts = newProducts;
      console.log(`[BOT] Transici√≥n a estado: menu (producto no confirmado)`);
      return menu;
    } else {
      const availableProducts = userStates[userId].availableProducts;
      const selectedProduct = availableProducts.find(
        (p) => p._id === userStates[userId].selectedProductId
      );
      console.log(`[BOT] Respuesta inv√°lida en confirm-product`);
      return `Por favor responde con 1 (s√≠) o 2 (no).\n\nüç∞ *${selectedProduct.name.toUpperCase()}*\n\n${
        selectedProduct.description ? selectedProduct.description + "\n" : ""
      }üí≤Precio: $${
        selectedProduct.price
      }\n\n¬øConfirmas este producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // Men√∫ de sabores de helado (selecci√≥n m√∫ltiple y confirmaci√≥n)
  if (userStates[userId].state === "ice-cream-flavour") {
    const availableFlavours = userStates[userId].availableFlavours;
    const maxFlavours = userStates[userId].maxFlavours || 1;
    const selectedOptions = userMessage
      .split(/[\,\s]+/)
      .map((x) => parseInt(x, 10))
      .filter((x) => !isNaN(x));
    if (
      !availableFlavours ||
      selectedOptions.length === 0 ||
      selectedOptions.some(
        (opt) => opt < 1 || opt > availableFlavours.length
      ) ||
      selectedOptions.length > maxFlavours
    ) {
      const { menu } = await getFlavourMenu();
      console.log(`[BOT] Selecci√≥n de sabores inv√°lida`);
      return (
        `‚ùå *Selecci√≥n inv√°lida*\n\nüí° *Recuerda:*\n` +
        `‚Ä¢ Puedes elegir hasta ${maxFlavours} sabor${
          maxFlavours > 1 ? "es" : ""
        }\n` +
        `‚Ä¢ Usa n√∫meros del 1 al ${availableFlavours.length}\n` +
        `‚Ä¢ Separa con espacios: *1 3 5*\n\n${menu}`
      );
    }
    userStates[userId].pendingFlavours = selectedOptions;
    const selectedFlavours = selectedOptions.map(
      (opt) => availableFlavours[opt - 1].name
    );
    userStates[userId].state = "confirm-flavours";
    console.log(
      `[BOT] Transici√≥n a estado: confirm-flavours (sabores: ${selectedFlavours.join(
        ", "
      )})`
    );
    return `üç¶ *Los sabores que elegiste son:* ${selectedFlavours.join(
      ", "
    )}\n\n¬øEs correcto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
  }

  // Confirmaci√≥n de sabores
  if (userStates[userId].state === "confirm-flavours") {
    console.log(`[BOT] En estado confirm-flavours, mensaje: '${userMessage}'`);
    const availableFlavours = userStates[userId].availableFlavours;
    const maxFlavours = userStates[userId].maxFlavours || 1;
    const selectedOptions = userStates[userId].pendingFlavours || [];
    const selectedFlavours = selectedOptions.map(
      (opt) => availableFlavours[opt - 1].name
    );
    console.log(
      `[BOT] Sabores seleccionados: ${selectedFlavours.join(
        ", "
      )}, maxFlavours: ${maxFlavours}`
    );

    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      if (selectedOptions.length < maxFlavours) {
        const remaining = maxFlavours - selectedOptions.length;
        userStates[userId].state = "add-more-flavour";
        console.log(`[BOT] Transici√≥n a estado: add-more-flavour`);
        return `A√∫n puedes elegir ${remaining} sabor${
          remaining > 1 ? "es" : ""
        } m√°s, ¬øquieres hacerlo?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
      } else {
        // Guardar sabores confirmados y ir al men√∫ de add-ons
        console.log(`[BOT] Sabores completos, guardando y yendo a add-ons`);
        userStates[userId].confirmedFlavours = selectedFlavours;
        userStates[userId].state = "add-ons-selection";
        const { menu, addOns } = await getAddOnsMenu();
        userStates[userId].availableAddOns = addOns;
        console.log(
          `[BOT] Transici√≥n a estado: add-ons-selection, addOns disponibles: ${addOns.length}`
        );
        return menu;
      }
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "ice-cream-flavour";
      console.log(
        `[BOT] Transici√≥n a estado: ice-cream-flavour (repetir selecci√≥n)`
      );
      return await getFlavourMenu().then(
        ({ menu }) =>
          menu +
          `\n\nüí° *Recuerda: Puedes elegir hasta ${maxFlavours} sabores de una vez*\n` +
          `üìù *Ejemplo: 1 3 5* (para elegir los sabores 1, 3 y 5)`
      );
    } else {
      console.log(`[BOT] Respuesta inv√°lida en confirm-flavours`);
      return `Por favor responde con 1 (s√≠) o 2 (no).\n\nüç¶ *Los sabores que elegiste son:* ${selectedFlavours.join(
        ", "
      )}\n\n¬øEs correcto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // ¬øAgregar m√°s sabores?
  if (userStates[userId].state === "add-more-flavour") {
    const availableFlavours = userStates[userId].availableFlavours;
    const maxFlavours = userStates[userId].maxFlavours || 1;
    const selectedOptions = userStates[userId].pendingFlavours || [];
    const selectedFlavours = selectedOptions.map(
      (opt) => availableFlavours[opt - 1].name
    );
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      const remaining = maxFlavours - selectedOptions.length;
      const remainingFlavours = availableFlavours
        .map((f, i) => ({ ...f, idx: i + 1 }))
        .filter((f) => !selectedOptions.includes(f.idx));
      if (remainingFlavours.length === 0) {
        // Guardar sabores confirmados y mostrar men√∫ de add-ons
        userStates[userId].confirmedFlavours = selectedFlavours;
        userStates[userId].state = "add-ons-selection";
        const { menu, addOns } = await getAddOnsMenu();
        userStates[userId].availableAddOns = addOns;
        console.log(
          `[BOT] Transici√≥n a estado: add-ons-selection (sin m√°s sabores)`
        );
        return menu;
      }
      userStates[userId].state = "add-flavour-selection";
      userStates[userId].remainingFlavours = remainingFlavours;
      userStates[userId].remainingCount = remaining;
      let menu = `üç¶ *Elige ${remaining} sabor(es) m√°s:*\n\n`;
      remainingFlavours.forEach((f, i) => {
        menu += `${numberToEmoji(i + 1)} *${f.name}*\n`;
      });
      menu += `\nResponde con el n√∫mero de la opci√≥n.`;
      console.log(`[BOT] Transici√≥n a estado: add-flavour-selection`);
      return menu;
    } else if (userMessage === "2" || userMessage === "no") {
      // Guardar sabores confirmados y mostrar men√∫ de add-ons
      userStates[userId].confirmedFlavours = selectedFlavours;
      userStates[userId].state = "add-ons-selection";
      const { menu, addOns } = await getAddOnsMenu();
      userStates[userId].availableAddOns = addOns;
      console.log(
        `[BOT] Transici√≥n a estado: add-ons-selection (usuario no quiere m√°s sabores)`
      );
      return menu;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en add-more-flavour`);
      const remaining = maxFlavours - selectedOptions.length;
      return `Por favor responde con 1 (s√≠) o 2 (no).\n\nA√∫n puedes elegir ${remaining} sabor${
        remaining > 1 ? "es" : ""
      } m√°s, ¬øquieres hacerlo?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // Selecci√≥n de sabor adicional
  if (userStates[userId].state === "add-flavour-selection") {
    const remainingFlavours = userStates[userId].remainingFlavours || [];
    const remainingCount = userStates[userId].remainingCount || 1;
    const selectedOptions = userStates[userId].pendingFlavours || [];
    const opt = parseInt(userMessage, 10);
    if (isNaN(opt) || opt < 1 || opt > remainingFlavours.length) {
      let menu = `‚ùå Selecci√≥n inv√°lida.\n\nüç¶ *Elige ${remainingCount} sabor(es) m√°s:*\n\n`;
      remainingFlavours.forEach((f, i) => {
        menu += `${numberToEmoji(i + 1)} *${f.name}*\n`;
      });
      menu += `\nResponde con el n√∫mero de la opci√≥n.`;
      console.log(`[BOT] Selecci√≥n inv√°lida en add-flavour-selection`);
      return menu;
    }
    const newFlavourIdx = remainingFlavours[opt - 1].idx;
    selectedOptions.push(newFlavourIdx);
    userStates[userId].pendingFlavours = selectedOptions;
    const allFlavours = userStates[userId].availableFlavours;
    const selectedFlavours = selectedOptions.map(
      (idx) => allFlavours[idx - 1].name
    );
    userStates[userId].state = "confirm-flavours";
    console.log(
      `[BOT] Transici√≥n a estado: confirm-flavours (sabores: ${selectedFlavours.join(
        ", "
      )})`
    );
    return `üç¶ *Los sabores que elegiste son:* ${selectedFlavours.join(
      ", "
    )}\n\n¬øEs correcto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
  }

  // Selecci√≥n de add-ons
  if (userStates[userId].state === "add-ons-selection") {
    console.log(`[BOT] En estado add-ons-selection, mensaje: '${userMessage}'`);
    const availableAddOns = userStates[userId].availableAddOns;
    console.log(
      `[BOT] Add-ons disponibles:`,
      availableAddOns ? availableAddOns.length : "undefined"
    );

    const option = parseInt(userMessage, 10);
    console.log(
      `[BOT] Opci√≥n parseada: ${option}, rango v√°lido: 1 a ${
        availableAddOns.length + 1
      }`
    );

    if (isNaN(option) || option < 1 || option > availableAddOns.length + 1) {
      const { menu } = await getAddOnsMenu();
      console.log(`[BOT] Opci√≥n inv√°lida en add-ons-selection`);
      return `‚ùå Por favor, selecciona una opci√≥n v√°lida.\n\n${menu}`;
    }

    if (option === availableAddOns.length + 1) {
      // Usuario eligi√≥ "No, gracias" - ir directamente a confirmaci√≥n final
      userStates[userId].state = "show-ice-cream-confirmation";
      console.log(
        `[BOT] Transici√≥n a estado: show-ice-cream-confirmation (sin add-ons)`
      );
      return await showIceCreamConfirmation(userId);
    }

    // Usuario eligi√≥ un add-on
    const selectedAddOn = availableAddOns[option - 1];
    // Si el add-on es uno de los especiales, preguntar cantidad
    if (
      ["64f3b8caf0f00fea17c6ad9d", "6674b84f1f17aff336ef3fc5"].includes(
        selectedAddOn._id
      )
    ) {
      userStates[userId].selectedAddOn = selectedAddOn;
      userStates[userId].state = "ask-addon-quantity";
      return `üî¢ *¬øCu√°ntos* ${selectedAddOn.name.toUpperCase()} *quieres agregar?*\n\nPor favor, ingresa un n√∫mero (por ejemplo: 2).\n\n*Escribe 0 para cancelar y volver al men√∫ de toppings.*`;
    }
    // Si el add-on es el que necesita selecci√≥n de salsa
    if (selectedAddOn._id === "64f5045a4cd7d05507034a2f") {
      userStates[userId].selectedAddOn = selectedAddOn;
      userStates[userId].state = "sauce-flavour-selection";
      const { menu, availableSauces } = await getSauceFlavourMenu();
      userStates[userId].availableSauces = availableSauces;
      console.log(`[BOT] Transici√≥n a estado: sauce-flavour-selection`);
      return menu;
    }
    userStates[userId].selectedAddOn = selectedAddOn;
    userStates[userId].state = "confirm-add-on";
    console.log(`[BOT] Transici√≥n a estado: confirm-add-on`);
    return `üç´ *Add-on seleccionado:* ${selectedAddOn.name.toUpperCase()}\n\nüí≤Precio: $${
      selectedAddOn.price
    }\n\n¬øConfirmas este add-on?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
  }

  // Preguntar cantidad para add-ons especiales
  if (userStates[userId].state === "ask-addon-quantity") {
    const selectedAddOn = userStates[userId].selectedAddOn;
    const qty = parseInt(userMessage, 10);
    if (isNaN(qty) || qty < 0) {
      return `üî¢ *¬øCu√°ntos* ${selectedAddOn.name.toUpperCase()} *quieres agregar?*\n\nPor favor, ingresa un n√∫mero (por ejemplo: 2).\n\n*Escribe 0 para cancelar y volver al men√∫ de toppings.*`;
    }
    if (qty === 0) {
      userStates[userId].state = "add-ons-selection";
      const { menu } = await getAddOnsMenu();
      return menu;
    }
    // Guardar add-on con cantidad
    const addOnWithQty = { ...selectedAddOn, quantity: qty };
    userStates[userId].selectedAddOn = addOnWithQty;
    userStates[userId].state = "confirm-add-on";
    return `üç´ *Add-on seleccionado:* ${selectedAddOn.name.toUpperCase()}\nCantidad: ${qty}\nüí≤Precio unitario: $${
      selectedAddOn.price
    }\nüí≤Total: $${
      selectedAddOn.price * qty
    }\n\n¬øConfirmas este add-on?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
  }

  // Selecci√≥n de sabor de salsa
  if (userStates[userId].state === "sauce-flavour-selection") {
    console.log(
      `[BOT] En estado sauce-flavour-selection, mensaje: '${userMessage}'`
    );
    const availableSauces = userStates[userId].availableSauces;
    console.log(
      `[BOT] Salsas disponibles:`,
      availableSauces ? availableSauces.length : "undefined"
    );

    const option = parseInt(userMessage, 10);
    console.log(
      `[BOT] Opci√≥n parseada: ${option}, rango v√°lido: 1 a ${availableSauces.length}`
    );

    if (isNaN(option) || option < 1 || option > availableSauces.length) {
      const { menu } = await getSauceFlavourMenu();
      console.log(`[BOT] Opci√≥n inv√°lida en sauce-flavour-selection`);
      return `‚ùå Por favor, selecciona una opci√≥n v√°lida.\n\n${menu}`;
    }

    // Usuario eligi√≥ un sabor de salsa
    const selectedSauce = availableSauces[option - 1];
    const selectedAddOn = userStates[userId].selectedAddOn;

    // Guardar add-on con el sabor de salsa seleccionado
    const addOnWithSauce = {
      ...selectedAddOn,
      sauceFlavour: selectedSauce.name,
      displayName: `${selectedAddOn.name} - ${selectedSauce.name}`,
    };
    userStates[userId].selectedAddOn = addOnWithSauce;
    userStates[userId].state = "confirm-add-on";
    console.log(
      `[BOT] Transici√≥n a estado: confirm-add-on (con salsa: ${selectedSauce.name})`
    );
    return `üç´ *Add-on seleccionado:* ${selectedAddOn.name.toUpperCase()}\nüçØ Sabor: ${
      selectedSauce.name
    }\nüí≤Precio: $${
      selectedAddOn.price
    }\n\n¬øConfirmas este add-on?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
  }

  // Confirmaci√≥n de add-on
  if (userStates[userId].state === "confirm-add-on") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      // Guardar add-on confirmado
      if (!userStates[userId].selectedAddOns)
        userStates[userId].selectedAddOns = [];
      userStates[userId].selectedAddOns.push(userStates[userId].selectedAddOn);
      userStates[userId].selectedAddOn = null;
      userStates[userId].state = "add-another-addon";
      console.log(`[BOT] Add-on confirmado, preguntar si quiere otro`);
      return `üç´ *¬øQuieres agregar otro topping o complemento?*\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "add-ons-selection";
      const { menu } = await getAddOnsMenu();
      console.log(
        `[BOT] Transici√≥n a estado: add-ons-selection (add-on no confirmado)`
      );
      return menu;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en confirm-add-on`);
      return `Por favor responde con 1 (s√≠) o 2 (no).\n\nüç´ *Add-on seleccionado:* ${userStates[
        userId
      ].selectedAddOn.name.toUpperCase()}\n\nüí≤Precio: $${
        userStates[userId].selectedAddOn.price
      }\n\n¬øConfirmas este add-on?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // Preguntar si quiere otro add-on
  if (userStates[userId].state === "add-another-addon") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      // Mostrar men√∫ de add-ons quitando los ya elegidos
      const { menu, addOns } = await getAddOnsMenu();
      const alreadySelected = userStates[userId].selectedAddOns || [];
      const filteredAddOns = addOns.filter(
        (a) => !alreadySelected.some((sel) => sel._id === a._id)
      );
      userStates[userId].availableAddOns = filteredAddOns;
      userStates[userId].state = "add-ons-selection";
      if (filteredAddOns.length === 0) {
        // No quedan m√°s add-ons
        userStates[userId].state = "show-ice-cream-confirmation";
        return await showIceCreamConfirmation(userId);
      }
      let filteredMenu = `üç´ *¬øQuieres agregar otro topping o complemento?*\n\n`;
      filteredAddOns.forEach((addon, i) => {
        filteredMenu += `${numberToEmoji(
          i + 1
        )} *${addon.name.toUpperCase()}* - $${addon.price}\n`;
      });
      filteredMenu += `\n${numberToEmoji(
        filteredAddOns.length + 1
      )} *No, gracias*\n`;
      filteredMenu += `\nResponde con el n√∫mero de la opci√≥n (1-${
        filteredAddOns.length + 1
      })`;
      return filteredMenu;
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "show-ice-cream-confirmation";
      return await showIceCreamConfirmation(userId);
    } else {
      return `Por favor responde con 1 (s√≠) o 2 (no).\n\n¬øQuieres agregar otro topping o complemento?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // Despu√©s de mostrar descripci√≥n y precio de un producto (no helado)
  if (userStates[userId].state === "show-product-info") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      // Solo volver al men√∫ principal, el producto ya est√° en el carrito
      userStates[userId].state = "menu";
      const { menu, availableProducts: newProducts } = await getMainMenu();
      userStates[userId].availableProducts = newProducts;
      console.log(`[BOT] Transici√≥n a estado: menu (agregar otro producto)`);
      return menu;
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "delivery-option";
      console.log(
        `[BOT] Transici√≥n a estado: delivery-option (pedido finalizado)`
      );
      return `${renderCart(
        userStates[userId].cart
      )}\n\nüöö *¬øC√≥mo quieres recibir tu pedido?*\n\n1Ô∏è‚É£ üè† *Env√≠o a domicilio*\n2Ô∏è‚É£ üè™ *Retirar en el local*`;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en show-product-info`);
      return `${renderCart(
        userStates[userId].cart
      )}\n\n¬øQuieres agregar otro producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // Despu√©s de confirmar sabores de helado
  if (userStates[userId].state === "show-flavour-confirmation") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      // Preservar el carrito y solo cambiar el estado
      userStates[userId].state = "menu";
      const { menu, availableProducts: newProducts } = await getMainMenu();
      userStates[userId].availableProducts = newProducts;
      console.log(
        `[BOT] Transici√≥n a estado: menu (agregar otro producto tras sabores)`
      );
      return menu;
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "delivery-option";
      console.log(
        `[BOT] Transici√≥n a estado: delivery-option (pedido finalizado tras sabores)`
      );
      return `${renderCart(
        userStates[userId].cart
      )}\n\nüöö *¬øC√≥mo quieres recibir tu pedido?*\n\n1Ô∏è‚É£ üè† *Env√≠o a domicilio*\n2Ô∏è‚É£ üè™ *Retirar en el local*`;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en show-flavour-confirmation`);
      return `${renderCart(
        userStates[userId].cart
      )}\n\n¬øQuieres agregar otro producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // Opci√≥n de entrega
  if (userStates[userId].state === "delivery-option") {
    // Verificar horarios nuevamente antes de procesar la entrega (excepto si est√° en modo test)
    if (!userStates[userId].testMode && !isBusinessHours()) {
      console.log(
        `[BOT] Usuario ${userId} intent√≥ procesar entrega fuera de horario`
      );
      return getOutOfHoursMessage();
    }

    if (
      userMessage === "1" ||
      userMessage === "env√≠o" ||
      userMessage === "domicilio"
    ) {
      userStates[userId].state = "ask-address";
      console.log(`[BOT] Transici√≥n a estado: ask-address`);
      return `üìç *Por favor, env√≠a tu direcci√≥n completa:*\n\nIncluye:\n‚Ä¢ Calle y n√∫mero\n‚Ä¢ Entre calles\n‚Ä¢ Barrio\n\nEjemplo: "Av. Corrientes 1234, entre Callao y Uruguay, Palermo"`;
    } else if (
      userMessage === "2" ||
      userMessage === "retirar" ||
      userMessage === "local"
    ) {
      userStates[userId].state = "pickup-confirmation";
      console.log(`[BOT] Transici√≥n a estado: pickup-confirmation`);
      return `üè™ *Retiro en local confirmado*\n\n${renderCart(
        userStates[userId].cart
      )}\n\nüìç *Direcci√≥n del local:*\nAv. Principal 123, Centro\nHorarios: Lunes a Viernes 20:00 - 24:00\nS√°bados, Domingos y Feriados: 13:00 - 01:00\n\n¬°Gracias por tu pedido! Te avisaremos cuando est√© listo para retirar.`;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en delivery-option`);
      return `‚ùå Por favor, selecciona una opci√≥n v√°lida.\n\nüöö *¬øC√≥mo quieres recibir tu pedido?*\n\n1Ô∏è‚É£ üè† *Env√≠o a domicilio*\n2Ô∏è‚É£ üè™ *Retirar en el local*`;
    }
  }

  // Solicitar direcci√≥n
  if (userStates[userId].state === "ask-address") {
    if (userMessage && userMessage.length > 10) {
      userStates[userId].deliveryAddress = userMessage;
      userStates[userId].state = "address-confirmation";
      console.log(`[BOT] Transici√≥n a estado: address-confirmation`);
      return `üìç *Direcci√≥n confirmada:*\n${userMessage}\n\n${renderCart(
        userStates[userId].cart
      )}\n\n¬øEs correcta la direcci√≥n?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No (escribir de nuevo)`;
    } else {
      console.log(`[BOT] Direcci√≥n muy corta en ask-address`);
      return `‚ùå Por favor, env√≠a una direcci√≥n m√°s completa.\n\nIncluye:\n‚Ä¢ Calle y n√∫mero\n‚Ä¢ Entre calles\n‚Ä¢ Barrio\n\nEjemplo: "Av. Corrientes 1234, entre Callao y Uruguay, Palermo"`;
    }
  }

  // Confirmar direcci√≥n
  if (userStates[userId].state === "address-confirmation") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      userStates[userId].state = "order-complete";
      console.log(`[BOT] Transici√≥n a estado: order-complete`);
      return `‚úÖ *¬°Pedido confirmado!*\n\n${renderCart(
        userStates[userId].cart
      )}\n\nüìç *Direcci√≥n de entrega:*\n${
        userStates[userId].deliveryAddress
      }\n\nüöö Tu pedido ser√° entregado en aproximadamente 30-45 minutos.\n\n¬°Gracias por tu compra! Si quieres hacer otro pedido, escribe "menu".`;
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "ask-address";
      console.log(
        `[BOT] Transici√≥n a estado: ask-address (direcci√≥n incorrecta)`
      );
      return `üìç *Por favor, env√≠a tu direcci√≥n completa nuevamente:*\n\nIncluye:\n‚Ä¢ Calle y n√∫mero\n‚Ä¢ Entre calles\n‚Ä¢ Barrio\n\nEjemplo: "Av. Corrientes 1234, entre Callao y Uruguay, Palermo"`;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en address-confirmation`);
      return `‚ùå Por favor, responde con 1 (s√≠) o 2 (no).\n\nüìç *Direcci√≥n confirmada:*\n${userStates[userId].deliveryAddress}\n\n¬øEs correcta la direcci√≥n?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No (escribir de nuevo)`;
    }
  }

  // Confirmar retiro en local
  if (userStates[userId].state === "pickup-confirmation") {
    userStates[userId].state = "order-complete";
    console.log(`[BOT] Transici√≥n a estado: order-complete (retiro)`);
    return `‚úÖ *¬°Pedido confirmado para retiro!*\n\n${renderCart(
      userStates[userId].cart
    )}\n\nüè™ *Retiro en local*\nüìç Av. Principal 123, Centro\nHorarios: Lunes a Viernes 20:00 - 24:00\nS√°bados, Domingos y Feriados: 13:00 - 01:00\n\n‚è∞ Tu pedido estar√° listo en aproximadamente 15-20 minutos.\n\n¬°Gracias por tu compra! Si quieres hacer otro pedido, escribe "menu".`;
  }

  // Pedido completado - solo responder a comandos espec√≠ficos
  if (userStates[userId].state === "order-complete") {
    if (["menu", "hola", "inicio"].includes(userMessage)) {
      // Limpiar carrito y reiniciar estado para nuevo pedido
      userStates[userId] = {
        state: "menu",
        testMode: userStates[userId].testMode,
        cart: [],
      };
      const { menu, availableProducts } = await getMainMenu();
      userStates[userId].availableProducts = availableProducts;
      console.log(
        `[BOT] Transici√≥n a estado: menu (nuevo pedido despu√©s de completar)`
      );
      return menu;
    } else {
      console.log(
        `[BOT] Usuario en estado order-complete, mensaje: '${userMessage}'`
      );
      return `‚úÖ *¬°Tu pedido ya fue confirmado!*\n\nSi quieres hacer otro pedido, escribe "menu" para empezar de nuevo.`;
    }
  }

  // Si no hay respuesta v√°lida
  const { menu } = await getMainMenu();
  console.log(
    `[BOT] Comando no reconocido, estado: ${userStates[userId].state}`
  );
  return `‚ùå Comando no reconocido. Escribe "menu" para volver al men√∫ principal.\n\n${menu}`;
}

async function shouldIgnoreMessage(message) {
  let name;
  let log;
  const isFromMe = message._data.id.fromMe;
  const targetNumber = "5491130350056@c.us"; // The number you don't want to forward messages to/from

  const hasImage = message.type === "image";

  const chat = await message.getChat();
  // Check if the chat is archived
  const isArchived = chat.archived;
  // Ignore status updates (WhatsApp Stories)
  const isStory = message.from === "status@broadcast";
  const isSticker = message.type === "sticker";
  const isVoiceMessage = message.type === "ptt";
  console.log("message type is: ");
  console.log(message.type);
  const isTextLess = !message.body || message.body === "";

  //ignore group messages
  const isGroupChat = chat.id.server === "g.us";
  //ignore muted chats
  const isMuted = chat.muteExpiration === -1;
  // Skip empty or "This message can't be displayed here" messages
  const isEmpty = !hasImage && isTextLess && !isVoiceMessage && !isSticker;
  // Ignore messages sent to or received from the target number
  const isIrrelevant =
    message.from === targetNumber || message.to === targetNumber;

  // Ignore messages from users who are talking to a human
  const isUserWithHumanSupport = usersWithHumanSupport.has(message.from);

  const reasonsToIgnoreMessage = Array.from([]);

  if (isGroupChat) reasonsToIgnoreMessage.push("isGroupChat");
  if (isArchived) reasonsToIgnoreMessage.push("isArchived");
  if (isStory) reasonsToIgnoreMessage.push("isStory");

  /* if (isIrrelevant) reasonsToIgnoreMessage.push("isIrrelevant"); */
  if (isMuted) reasonsToIgnoreMessage.push("isMuted");
  if (isEmpty) reasonsToIgnoreMessage.push("isEmpty");
  if (isUserWithHumanSupport)
    reasonsToIgnoreMessage.push("isUserWithHumanSupport");

  if (reasonsToIgnoreMessage.length > 0) {
    console.log("--------------- START -------------------");
    console.log("return triggered");
    console.log("reason:", reasonsToIgnoreMessage.join(", "));
    console.log("--------------- END -------------------");
    return reasonsToIgnoreMessage.length;
  }
}

// Funci√≥n para obtener estad√≠sticas de usuarios
function getBotStats() {
  return {
    totalUsers: Object.keys(userStates).length,
    usersWithHumanSupport: usersWithHumanSupport.size,
    activeBotUsers: Object.keys(userStates).length - usersWithHumanSupport.size,
  };
}

module.exports = {
  shouldIgnoreMessage,
  handleBotMessage,
  getBotStats,
  usersWithHumanSupport,
  isBusinessHours,
  getBusinessHoursMessage,
  getOutOfHoursMessage,
  userStates,
};
