const axios = require("axios");

// Estado de conversaci√≥n por usuario
const userStates = {}; // { [userId]: { state: 'menu' | 'product' | 'ice-cream-flavour' | 'human_support', selectedProductId, ... } }

// Usuarios que est√°n hablando con una persona real (bot desactivado)
const usersWithHumanSupport = new Set();

// Usuarios muteados temporalmente tras confirmar pedido
const mutedUsers = {};

// Funci√≥n para verificar si estamos en horario de atenci√≥n
function isBusinessHours() {
  const now = new Date();
  const currentHour = now.getHours();
  const currentDay = now.getDay(); // 0 = Domingo, 1 = Lunes, ..., 6 = S√°bado

  // Horarios de atenci√≥n:
  // Lunes a Viernes: 20:00 - 24:00
  // S√°bados, Domingos y Feriados: 13:00 - 01:00 del d√≠a siguiente

  const isWeekday = currentDay >= 1 && currentDay <= 5; // Lunes a Viernes
  const isWeekend = currentDay === 0 || currentDay === 6; // Domingo o S√°bado

  if (isWeekday) {
    // Lunes a Viernes: 20:00 - 24:00
    return currentHour >= 20 && currentHour < 24;
  } else if (isWeekend) {
    // S√°bados y Domingos: 13:00 - 01:00 del d√≠a siguiente
    return currentHour >= 13 || currentHour < 1;
  }

  return false;
}

// Funci√≥n para obtener el mensaje de horarios
function getBusinessHoursMessage() {
  return "üïê *Horarios de atenci√≥n:*\nLunes a Viernes: 20:00 - 24:00\nS√°bados, Domingos y Feriados: 13:00 - 01:00";
}

// Funci√≥n para obtener mensaje de fuera de horario
function getOutOfHoursMessage() {
  return "‚ùå *Lo sentimos, estamos cerrados*\n\nüïê *Horarios de atenci√≥n:*\nLunes a Viernes: 20:00 - 24:00\nS√°bados, Domingos y Feriados: 13:00 - 01:00\n\nPor favor, vuelve a intentar durante nuestro horario de atenci√≥n.";
}

// Helper: number to emoji, usando un emoji por cada d√≠gito
function numberToEmoji(n) {
  const emojiMap = ["0Ô∏è‚É£", "1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£"];
  return n
    .toString()
    .split("")
    .map((digit) => emojiMap[parseInt(digit, 10)])
    .join("");
}

// Funci√≥n para mostrar el men√∫ principal din√°mico
async function getMainMenu({ allowCancelAddProduct = false } = {}) {
  try {
    const { data: products } = await axios.get(
      "http://localhost:3000/products"
    );
    // Filtrar productos disponibles y excluir add-ons (se seleccionan en el submen√∫)
    const availableProducts = products.filter(
      (p) => !p.outOfStock && p.type !== "add-on"
    );
    let menu = `ü§ñ *¬°Gracias por comunicarte con Dulce Tentaci√≥n!*\n\nüì± *Tambi√©n puedes ver nuestro cat√°logo completo online:*\nüåê https://dulce-tentacion-mp.netlify.app/\n\n`;
    menu += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    menu += `0Ô∏è‚É£ *üí¨ HABLAR CON UNA PERSONA REAL*\n`;
    menu += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    availableProducts.forEach((p, i) => {
      menu += `${numberToEmoji(i + 1)} *${p.name.toUpperCase()}* - $${
        p.price
      }\n`;
    });
    let lastOptionNum = availableProducts.length + 1;
    if (allowCancelAddProduct) {
      menu += `\n${numberToEmoji(lastOptionNum)} *No agregar m√°s productos*`;
      lastOptionNum++;
    }
    menu += `\n\nResponde con el n√∫mero de la opci√≥n (0-${lastOptionNum - 1})`;
    menu += `\n\n${getBusinessHoursMessage()}`;
    return { menu, availableProducts };
  } catch (e) {
    return {
      menu: "‚ùå Error al obtener los productos. Intenta m√°s tarde.",
      availableProducts: [],
    };
  }
}

// Funci√≥n para mostrar men√∫ de sabores de helado
async function getFlavourMenu(maxFlavours = 1) {
  try {
    const { data: flavours } = await axios.get(
      "http://localhost:3000/generic/flavour"
    );
    const availableFlavours = flavours.filter((f) => !f.outOfStock);
    let menu = `üç¶ *Elige hasta ${maxFlavours} sabores:*\n\n`;
    availableFlavours.forEach((f, i) => {
      menu += `${numberToEmoji(i + 1)} *${f.name}*\n`;
    });
    menu += `\nüí° *Puedes elegir m√∫ltiples sabores de una vez*\n`;
    menu += `üìù *Ejemplos:*\n`;
    menu += `‚Ä¢ Para elegir solo Vainilla: *1*\n`;
    menu += `‚Ä¢ Para elegir Vainilla y Chocolate: *1 2*\n`;
    menu += `‚Ä¢ Para elegir Vainilla, Chocolate y Frutilla: *1 2 3*\n`;

    return { menu, availableFlavours };
  } catch (e) {
    return {
      menu: "‚ùå Error al obtener los sabores. Intenta m√°s tarde.",
      availableFlavours: [],
    };
  }
}

// Funci√≥n para mostrar men√∫ de add-ons
async function getAddOnsMenu() {
  try {
    const { data: products } = await axios.get(
      "http://localhost:3000/products"
    );
    const addOns = products.filter((p) => p.type === "add-on" && !p.outOfStock);
    let menu = `üç´ *¬øQuieres agregar alg√∫n topping o complemento?*\n\n`;
    addOns.forEach((addon, i) => {
      menu += `${numberToEmoji(i + 1)} *${addon.name.toUpperCase()}* - $${
        addon.price
      }\n`;
    });
    menu += `\n*No, gracias*\n`;
    menu += `\nResponde con el n√∫mero de la opci√≥n (1-${addOns.length}) o escribe *no*`;
    return { menu, addOns };
  } catch (e) {
    return {
      menu: "‚ùå Error al obtener los add-ons. Intenta m√°s tarde.",
      addOns: [],
    };
  }
}

// Funci√≥n para mostrar men√∫ de sabores de salsa
async function getSauceFlavourMenu() {
  try {
    const { data: sauces } = await axios.get(
      "http://localhost:3000/generic/sauce"
    );
    const availableSauces = sauces.filter((s) => !s.outOfStock);
    let menu = `üçØ *Elige un sabor de salsa:*\n\n`;
    availableSauces.forEach((s, i) => {
      menu += `${numberToEmoji(i + 1)} *${s.name}*\n`;
    });
    menu += `\nResponde con el n√∫mero de la opci√≥n (1-${availableSauces.length})`;
    return { menu, availableSauces };
  } catch (e) {
    return {
      menu: "‚ùå Error al obtener los sabores de salsa. Intenta m√°s tarde.",
      availableSauces: [],
    };
  }
}

// Helper para mostrar el carrito
function renderCart(cart) {
  if (!cart || cart.length === 0) return "üõí *Tu carrito est√° vac√≠o.*";

  let msg = "üõí *Tu carrito actual:*\n";
  let totalGeneral = 0;

  cart.forEach((item, i) => {
    const price = item["totalPrice"] || item.price;
    const precioBase = item.price;
    totalGeneral += price;

    msg += `${numberToEmoji(i + 1)} *${item.name.toUpperCase()}*\n`;

    // Mostrar cantidad si existe
    if (item.quantity && item.quantity > 1) {
      msg += `   üî¢ Cantidad: ${item.quantity}\n`;
      msg += `   üí≤Precio unitario: $${precioBase}\n`;
      msg += `   üí≤Total: $${price}`;
    } else {
      msg += `   üí≤Precio: $${precioBase}`;
    }

    if (item.flavours && item.flavours.length > 0) {
      msg += `\n   üç¶ Sabores: ${item.flavours.join(", ")}`;
    }

    if (item["addOns"] && item["addOns"].length > 0) {
      msg += `\n   üç´ Aderezos:`;
      // Mostrar detalles de cada add-on
      const addOnsArr = item["addOns"];
      const addOnsData = item.selectedAddOnsData || [];
      addOnsArr.forEach((name, idx) => {
        // Buscar si hay info de cantidad y sabor de salsa
        const data = addOnsData.find(
          (a) => a && (a.name === name || a.displayName === name)
        );
        if (data) {
          let addOnDisplay = `\n     - ${name}`;
          if (data.sauceFlavour) {
            addOnDisplay += ` (${data.sauceFlavour})`;
          }
          if (data.quantity && data.quantity > 1) {
            addOnDisplay += ` x${data.quantity} ($${data.price}) = $${
              data.price * data.quantity
            }`;
          } else {
            addOnDisplay += ` ($${data.price})`;
          }
          msg += addOnDisplay;
        } else {
          msg += `\n     - ${name}`;
        }
      });

      if (item["addOnsPrice"] && item["addOnsPrice"] > 0) {
        msg += `\n   üí≤Total aderezos: +$${item["addOnsPrice"]}`;
      }
    }

    if (item["totalPrice"] && item["totalPrice"] !== item.price) {
      msg += `\n   üí≤Total  producto: $${item["totalPrice"]}`;
    }

    msg += "\n";
  });

  msg += `\nüí∞ *TOTAL GENERAL: $${totalGeneral}*`;
  return msg;
}

// Funci√≥n para mostrar confirmaci√≥n final del helado con add-ons
async function showIceCreamConfirmation(userId) {
  const availableProducts = userStates[userId].availableProducts;
  const selectedProduct = availableProducts.find(
    (p) => p._id === userStates[userId].selectedProductId
  );
  const confirmedFlavours = userStates[userId].confirmedFlavours || [];
  const selectedAddOns = userStates[userId].selectedAddOns || [];

  // Crear el item del carrito
  const cartItem = {
    name: selectedProduct.name,
    price: selectedProduct.price,
    _id: selectedProduct._id,
    flavours: confirmedFlavours,
  };

  // Agregar add-ons si existen
  if (selectedAddOns.length > 0) {
    cartItem["addOns"] = selectedAddOns.map((a) => {
      // Si tiene sabor de salsa, usar el displayName, sino usar el nombre normal
      return a.displayName || a.name;
    });
    cartItem["addOnsPrice"] = selectedAddOns.reduce(
      (sum, a) => sum + a.price * (a.quantity || 1),
      0
    );
    cartItem["totalPrice"] = selectedProduct.price + cartItem["addOnsPrice"];
    cartItem["selectedAddOnsData"] = selectedAddOns.map((a) => {
      // Asegurar que se guarde toda la informaci√≥n del add-on incluyendo precio
      return {
        name: a.displayName || a.name,
        price: a.price,
        quantity: a.quantity || 1,
        sauceFlavour: a.sauceFlavour,
        _id: a._id,
      };
    });
  }

  userStates[userId].cart.push(cartItem);
  userStates[userId].state = "show-flavour-confirmation";
  // Limpiar add-ons seleccionados para el pr√≥ximo producto
  userStates[userId].selectedAddOns = [];

  return `${renderCart(
    userStates[userId].cart
  )}\n\n¬øQuieres agregar otro producto?\n\nResponde con *s√≠* o *no*`;
}

// Formatea la descripci√≥n: primera letra may√∫scula, salto de l√≠nea tras cada punto y al final
function formatDescription(desc) {
  if (!desc || typeof desc !== "string") return "";
  let trimmed = desc.trim();
  if (trimmed.length === 0) return "";
  // Primera letra en may√∫scula
  trimmed = trimmed.charAt(0).toUpperCase() + trimmed.slice(1);
  // Salto de l√≠nea despu√©s de cada punto (seguido o no de espacio)
  trimmed = trimmed.replace(/\.(\s+|$)/g, ".\n");
  // Si no termina en punto, agregar salto de l√≠nea al final
  if (!trimmed.endsWith(".\n")) trimmed += "\n";
  return trimmed;
}

// Utilidad para mensaje de cantidad de producto o add-on
function getQuantityPrompt({ name, description, price, isAddon = false }) {
  return `üî¢ *¬øCu√°ntos* ${name.toUpperCase()} *quieres agregar?*\n\n${
    description ? formatDescription(description) + "\n" : ""
  }üí≤Precio unitario: $${price}\n\nPor favor, ingresa un n√∫mero (por ejemplo: 2).\n\n*Escribe 0 para cancelar y volver al men√∫${
    isAddon ? " de toppings" : ""
  }.*`;
}

// Utilidad para mensaje de confirmaci√≥n de add-on
function getAddOnConfirmationPrompt({
  name,
  price,
  quantity = null,
  sauceFlavour = null,
}) {
  let prompt = `üç´ *Add-on seleccionado:* ${name.toUpperCase()}\n`;

  if (sauceFlavour) {
    prompt += `üçØ Sabor: ${sauceFlavour}\n`;
  }

  if (quantity && quantity > 1) {
    prompt += `Cantidad: ${quantity}\nüí≤Precio unitario: $${price}\nüí≤Total: $${
      price * quantity
    }\n`;
  } else {
    prompt += `üí≤Precio: $${price}\n`;
  }

  prompt += `\n¬øConfirmas este aderezo?\n\nResponde con *s√≠* o *no*`;
  return prompt;
}

// Funci√≥n principal para manejar mensajes del bot
async function handleBotMessage(message) {
  const userId = message.from;
  const userMessage = message.body ? message.body.toLowerCase().trim() : "";

  // Inicializar estado del usuario si no existe
  if (!userStates[userId]) {
    userStates[userId] = { state: "menu" };
  }
  // Inicializar carrito si no existe
  if (!userStates[userId].cart) userStates[userId].cart = [];

  // Verificar si el usuario est√° usando comandos de testing
  if (userMessage === "test_horario_on") {
    userStates[userId].testMode = true;
    console.log(`[BOT] Usuario ${userId} activ√≥ modo test`);
    return `‚úÖ *Modo test activado*\n\nüïê Verificaci√≥n de horarios desactivada\n\nPuedes usar el bot normalmente sin restricciones de horario.\n\nPara desactivar el modo test, escribe "test_horario_off"`;
  }

  if (userMessage === "test_horario_off") {
    userStates[userId].testMode = false;
    console.log(`[BOT] Usuario ${userId} desactiv√≥ modo test`);
    console.log(`[BOT] Estado actual del usuario:`, userStates[userId]);
    return `‚ùå *Modo test desactivado*\n\nüïê Verificaci√≥n de horarios reactivada\n\nAhora el bot respetar√° los horarios de atenci√≥n normales.\n\nEstado actual: testMode = ${userStates[userId].testMode}`;
  }

  // Verificar horarios de atenci√≥n al inicio (excepto si est√° en modo test)
  if (!userStates[userId].testMode && !isBusinessHours()) {
    console.log(
      `[BOT] Usuario ${userId} intent√≥ hacer un pedido fuera de horario`
    );
    console.log(
      `[BOT] testMode: ${
        userStates[userId].testMode
      }, isBusinessHours: ${isBusinessHours()}`
    );
    return getOutOfHoursMessage();
  }

  // Si el usuario est√° en modo persona real, no responder
  if (usersWithHumanSupport.has(userId)) return;

  // LOG: Estado actual y mensaje recibido
  console.log(
    `[BOT] Estado actual: ${userStates[userId].state}, Mensaje: '${userMessage}'`
  );

  // Mostrar men√∫ principal si el usuario escribe "menu", "hola" o "inicio"
  if (["menu", "hola", "inicio"].includes(userMessage)) {
    userStates[userId] = {
      state: "menu",
      testMode: userStates[userId].testMode,
    };
    const { menu, availableProducts } = await getMainMenu();
    userStates[userId].availableProducts = availableProducts;
    console.log(`[BOT] Transici√≥n a estado: menu`);
    return menu;
  }

  // Comando especial para desactivar el bot por 1 hora en el chat actual
  if (userMessage === "/kill_bot") {
    return "ü§ñ El bot ha sido desactivado en este chat temporalmente.";
  }

  // Men√∫ principal din√°mico
  if (userStates[userId].state === "menu") {
    console.log(`[BOT] Procesando men√∫ principal, mensaje: '${userMessage}'`);
    const availableProducts = userStates[userId].availableProducts;
    console.log(
      `[BOT] Productos disponibles:`,
      availableProducts ? availableProducts.length : "undefined"
    );

    if (!availableProducts) {
      const { menu, availableProducts: products } = await getMainMenu();
      userStates[userId].availableProducts = products;
      console.log(`[BOT] Sin productos en estado, mostrando men√∫ principal`);
      return menu;
    }

    const option = parseInt(userMessage, 10);
    console.log(`[BOT] Opci√≥n parseada: ${option}, esNaN: ${isNaN(option)}`);
    console.log(`[BOT] Rango v√°lido: 0 a ${availableProducts.length + 1}`);

    if (isNaN(option) || option < 0 || option > availableProducts.length + 1) {
      const { menu } = await getMainMenu({ allowCancelAddProduct: false });
      console.log(`[BOT] Opci√≥n inv√°lida en men√∫ principal: ${option}`);
      return `‚ùå Por favor, selecciona una opci√≥n v√°lida.\n\n${menu}`;
    }

    console.log(`[BOT] Opci√≥n v√°lida seleccionada: ${option}`);

    if (option === 0) {
      usersWithHumanSupport.add(userId);
      userStates[userId] = {
        state: "human_support",
        testMode: userStates[userId].testMode,
      };
      return `üë®‚Äçüíº *Conectando con una persona real...*\n\n‚úÖ *Bot desactivado para esta conversaci√≥n*\n\nUn representante se pondr√° en contacto contigo pronto. Mientras tanto, puedes escribir libremente y ser√°s atendido por una persona real.`;
    }

    const selectedProduct = availableProducts[option - 1];
    console.log(`[BOT] Producto seleccionado:`, selectedProduct);
    userStates[userId].selectedProductId = selectedProduct._id;
    // Si es frozen-treat, saltar confirmaci√≥n y pedir cantidad directamente
    if (selectedProduct.type === "frozen-treat" && !selectedProduct.apiRoute) {
      userStates[userId].state = "ask-frozen-treat-quantity";
      console.log(
        `[BOT] Transici√≥n directa a estado: ask-frozen-treat-quantity (sin confirmaci√≥n)`
      );
      return getQuantityPrompt({
        name: selectedProduct.name,
        description: selectedProduct.description,
        price: selectedProduct.price,
        isAddon: false,
      });
    }
    // Mostrar confirmaci√≥n del producto para los dem√°s casos
    userStates[userId].state = "confirm-product";
    console.log(`[BOT] Transici√≥n a estado: confirm-product`);
    return `üç∞ *${selectedProduct.name.toUpperCase()}*\n\n${
      selectedProduct.description ? selectedProduct.description + "\n\n" : ""
    }üí≤Precio: $${
      selectedProduct.price
    }\n\n¬øConfirmas este producto?\n\nResponde con *s√≠* o *no*`;
  }

  // Confirmaci√≥n de producto seleccionado
  if (userStates[userId].state === "confirm-product") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      const availableProducts = userStates[userId].availableProducts;
      const selectedProduct = availableProducts.find(
        (p) => p._id === userStates[userId].selectedProductId
      );
      if (selectedProduct.type === "ice-cream") {
        userStates[userId].state = "ice-cream-flavour";
        userStates[userId].maxFlavours = selectedProduct.flavours || 1;
        const { menu, availableFlavours } = await getFlavourMenu(
          userStates[userId].maxFlavours
        );
        userStates[userId].availableFlavours = availableFlavours;
        console.log(
          `[BOT] Transici√≥n a estado: ice-cream-flavour (maxFlavours: ${userStates[userId].maxFlavours})`
        );
        return menu;
      } else if (
        selectedProduct.type === "frozen-treat" &&
        !selectedProduct.apiRoute
      ) {
        // Productos frozen-treat sin apiRoute necesitan selecci√≥n de cantidad
        userStates[userId].state = "ask-frozen-treat-quantity";
        console.log(`[BOT] Transici√≥n a estado: ask-frozen-treat-quantity`);
        return getQuantityPrompt({
          name: selectedProduct.name,
          description: selectedProduct.description,
          price: selectedProduct.price,
          isAddon: false,
        });
      } else {
        // Agregar producto al carrito directamente
        userStates[userId].cart.push({
          name: selectedProduct.name,
          price: selectedProduct.price,
          _id: selectedProduct._id,
        });
        userStates[userId].state = "show-product-info";
        console.log(`[BOT] Transici√≥n a estado: show-product-info`);
        return `${renderCart(
          userStates[userId].cart
        )}\n\n¬øQuieres agregar otro producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
      }
    } else if (userMessage === "2" || userMessage === "no") {
      // Preservar el carrito y solo cambiar el estado
      userStates[userId].state = "menu";
      const { menu, availableProducts: newProducts } = await getMainMenu();
      userStates[userId].availableProducts = newProducts;
      console.log(`[BOT] Transici√≥n a estado: menu (producto no confirmado)`);
      return menu;
    } else {
      const availableProducts = userStates[userId].availableProducts;
      const selectedProduct = availableProducts.find(
        (p) => p._id === userStates[userId].selectedProductId
      );
      console.log(`[BOT] Respuesta inv√°lida en confirm-product`);
      return `Por favor responde con *s√≠* o *no*.\n\nüç∞ *${selectedProduct.name.toUpperCase()}*\n\n$${
        selectedProduct.description ? selectedProduct.description + "\n\n" : ""
      }üí≤Precio: $${
        selectedProduct.price
      }\n\n¬øConfirmas este producto?\n\nResponde con *s√≠* o *no*`;
    }
  }

  // Men√∫ de sabores de helado (selecci√≥n m√∫ltiple y confirmaci√≥n)
  if (userStates[userId].state === "ice-cream-flavour") {
    const availableFlavours = userStates[userId].availableFlavours;
    const maxFlavours = userStates[userId].maxFlavours || 1;
    const selectedOptions = userMessage
      .split(/[\,\s]+/)
      .map((x) => parseInt(x, 10))
      .filter((x) => !isNaN(x));
    if (
      !availableFlavours ||
      selectedOptions.length === 0 ||
      selectedOptions.some(
        (opt) => opt < 1 || opt > availableFlavours.length
      ) ||
      selectedOptions.length > maxFlavours
    ) {
      const { menu } = await getFlavourMenu(maxFlavours);
      console.log(`[BOT] Selecci√≥n de sabores inv√°lida`);
      return (
        `‚ùå *Selecci√≥n inv√°lida*\n\nüí° *Recuerda:*\n` +
        `‚Ä¢ Puedes elegir hasta ${maxFlavours} sabor${
          maxFlavours > 1 ? "es" : ""
        }\n` +
        `‚Ä¢ Usa n√∫meros del 1 al ${availableFlavours.length}\n` +
        `‚Ä¢ Separa con espacios: *1 3 5*\n\n${menu}`
      );
    }
    userStates[userId].pendingFlavours = selectedOptions;
    const selectedFlavours = selectedOptions.map(
      (opt) => availableFlavours[opt - 1].name
    );
    userStates[userId].state = "confirm-flavours";
    console.log(
      `[BOT] Transici√≥n a estado: confirm-flavours (sabores: ${selectedFlavours.join(
        ", "
      )})`
    );
    return `üç¶ *Los sabores que elegiste son:* ${selectedFlavours.join(
      ", "
    )}\n\n¬øEs correcto?\n\nResponde con *s√≠* o *no*`;
  }

  // Confirmaci√≥n de sabores
  if (userStates[userId].state === "confirm-flavours") {
    console.log(`[BOT] En estado confirm-flavours, mensaje: '${userMessage}'`);
    const availableFlavours = userStates[userId].availableFlavours;
    const maxFlavours = userStates[userId].maxFlavours || 1;
    const selectedOptions = userStates[userId].pendingFlavours || [];
    const selectedFlavours = selectedOptions.map(
      (opt) => availableFlavours[opt - 1].name
    );
    console.log(
      `[BOT] Sabores seleccionados: ${selectedFlavours.join(
        ", "
      )}, maxFlavours: ${maxFlavours}`
    );

    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      if (selectedOptions.length < maxFlavours) {
        const remaining = maxFlavours - selectedOptions.length;
        const remainingFlavours = availableFlavours
          .map((f, i) => ({ ...f, idx: i + 1 }))
          .filter((f) => !selectedOptions.includes(f.idx));

        if (remainingFlavours.length === 0) {
          // No hay m√°s sabores disponibles, ir directamente a add-ons
          userStates[userId].confirmedFlavours = selectedFlavours;
          userStates[userId].state = "add-ons-selection";
          const { menu, addOns } = await getAddOnsMenu();
          userStates[userId].availableAddOns = addOns;
          console.log(
            `[BOT] Transici√≥n a estado: add-ons-selection (sin m√°s sabores disponibles)`
          );
          return menu;
        }

        userStates[userId].state = "add-flavour-selection";
        userStates[userId].remainingFlavours = remainingFlavours;
        userStates[userId].remainingCount = remaining;
        let menu = `üç¶ *Elige hasta ${remaining} sabor(es) m√°s:*\n\n`;
        menu += `${numberToEmoji(0)} *No elegir m√°s sabores*\n`;
        remainingFlavours.forEach((f, i) => {
          menu += `${numberToEmoji(i + 1)} *${f.name}*\n`;
        });
        menu += `\nResponde con el n√∫mero de la opci√≥n (0-${remainingFlavours.length}).`;
        console.log(`[BOT] Transici√≥n a estado: add-flavour-selection`);
        return menu;
      } else {
        // Guardar sabores confirmados y ir al men√∫ de add-ons
        console.log(`[BOT] Sabores completos, guardando y yendo a add-ons`);
        userStates[userId].confirmedFlavours = selectedFlavours;
        userStates[userId].state = "add-ons-selection";
        const { menu, addOns } = await getAddOnsMenu();
        userStates[userId].availableAddOns = addOns;
        console.log(
          `[BOT] Transici√≥n a estado: add-ons-selection, addOns disponibles: ${addOns.length}`
        );
        return menu;
      }
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "ice-cream-flavour";
      console.log(
        `[BOT] Transici√≥n a estado: ice-cream-flavour (repetir selecci√≥n)`
      );
      return await getFlavourMenu(userStates[userId].maxFlavours).then(
        ({ menu }) =>
          menu +
          `\n\nüí° *Recuerda: Puedes elegir hasta ${userStates[userId].maxFlavours} sabores de una vez*\n` +
          `üìù *Ejemplo: 1 3 5* (para elegir los sabores 1, 3 y 5)`
      );
    } else {
      console.log(`[BOT] Respuesta inv√°lida en confirm-flavours`);
      return `Por favor responde con 1 (s√≠) o 2 (no).\n\nüç¶ *Los sabores que elegiste son:* ${selectedFlavours.join(
        ", "
      )}\n\n¬øEs correcto?\n\nResponde con *s√≠* o *no*`;
    }
  }

  // Selecci√≥n de sabor adicional
  if (userStates[userId].state === "add-flavour-selection") {
    const remainingFlavours = userStates[userId].remainingFlavours || [];
    const remainingCount = userStates[userId].remainingCount || 1;
    const selectedOptions = userStates[userId].pendingFlavours || [];
    const opt = parseInt(userMessage, 10);

    // Manejar opci√≥n 0 (no elegir m√°s sabores)
    if (opt === 0) {
      const selectedFlavours = selectedOptions.map(
        (idx) => userStates[userId].availableFlavours[idx - 1].name
      );
      userStates[userId].confirmedFlavours = selectedFlavours;
      userStates[userId].state = "add-ons-selection";
      const { menu, addOns } = await getAddOnsMenu();
      userStates[userId].availableAddOns = addOns;
      console.log(
        `[BOT] Transici√≥n a estado: add-ons-selection (usuario no quiere m√°s sabores)`
      );
      return menu;
    }

    if (isNaN(opt) || opt < 1 || opt > remainingFlavours.length) {
      let menu = `‚ùå Selecci√≥n inv√°lida.\n\nüç¶ *Elige hasta ${remainingCount} sabor(es) m√°s:*\n\n`;
      menu += `${numberToEmoji(0)} *No elegir m√°s sabores*\n`;
      remainingFlavours.forEach((f, i) => {
        menu += `${numberToEmoji(i + 1)} *${f.name}*\n`;
      });
      menu += `\nResponde con el n√∫mero de la opci√≥n (0-${remainingFlavours.length}).`;
      console.log(`[BOT] Selecci√≥n inv√°lida en add-flavour-selection`);
      return menu;
    }
    const newFlavourIdx = remainingFlavours[opt - 1].idx;
    selectedOptions.push(newFlavourIdx);
    userStates[userId].pendingFlavours = selectedOptions;
    const allFlavours = userStates[userId].availableFlavours;
    const selectedFlavours = selectedOptions.map(
      (idx) => allFlavours[idx - 1].name
    );
    userStates[userId].state = "confirm-flavours";
    console.log(
      `[BOT] Transici√≥n a estado: confirm-flavours (sabores: ${selectedFlavours.join(
        ", "
      )})`
    );
    return `üç¶ *Los sabores que elegiste son:* ${selectedFlavours.join(
      ", "
    )}\n\n¬øEs correcto?\n\nResponde con *s√≠* o *no*`;
  }

  // Selecci√≥n de add-ons
  if (userStates[userId].state === "add-ons-selection") {
    console.log(`[BOT] En estado add-ons-selection, mensaje: '${userMessage}'`);
    const availableAddOns = userStates[userId].availableAddOns;
    console.log(
      `[BOT] Add-ons disponibles:`,
      availableAddOns ? availableAddOns.length : "undefined"
    );

    // Verificar si el usuario escribi√≥ "no"
    if (userMessage === "no") {
      // Usuario eligi√≥ "No, gracias" - ir directamente a confirmaci√≥n final
      userStates[userId].state = "show-ice-cream-confirmation";
      console.log(
        `[BOT] Transici√≥n a estado: show-ice-cream-confirmation (sin add-ons)`
      );
      return await showIceCreamConfirmation(userId);
    }

    const option = parseInt(userMessage, 10);
    console.log(
      `[BOT] Opci√≥n parseada: ${option}, rango v√°lido: 1 a ${availableAddOns.length}`
    );

    if (isNaN(option) || option < 1 || option > availableAddOns.length) {
      const { menu } = await getAddOnsMenu();
      console.log(`[BOT] Opci√≥n inv√°lida en add-ons-selection`);
      return `‚ùå Por favor, selecciona una opci√≥n v√°lida.\n\n${menu}`;
    }

    // Usuario eligi√≥ un add-on
    const selectedAddOn = availableAddOns[option - 1];
    // Si el add-on es uno de los especiales, preguntar cantidad
    if (
      ["64f3b8caf0f00fea17c6ad9d", "6674b84f1f17aff336ef3fc5"].includes(
        selectedAddOn._id
      )
    ) {
      userStates[userId].selectedAddOn = selectedAddOn;
      userStates[userId].state = "ask-addon-quantity";
      return getQuantityPrompt({
        name: selectedAddOn.name,
        description: selectedAddOn.description,
        price: selectedAddOn.price,
        isAddon: true,
      });
    }
    // Si el add-on es el que necesita selecci√≥n de salsa
    if (selectedAddOn._id === "64f5045a4cd7d05507034a2f") {
      userStates[userId].selectedAddOn = selectedAddOn;
      userStates[userId].state = "sauce-flavour-selection";
      const { menu, availableSauces } = await getSauceFlavourMenu();
      userStates[userId].availableSauces = availableSauces;
      console.log(`[BOT] Transici√≥n a estado: sauce-flavour-selection`);
      return menu;
    }
    userStates[userId].selectedAddOn = selectedAddOn;
    userStates[userId].state = "confirm-add-on";
    console.log(`[BOT] Transici√≥n a estado: confirm-add-on`);
    return getAddOnConfirmationPrompt({
      name: selectedAddOn.name,
      price: selectedAddOn.price,
    });
  }

  // Preguntar cantidad para add-ons especiales
  if (userStates[userId].state === "ask-addon-quantity") {
    const selectedAddOn = userStates[userId].selectedAddOn;
    const qty = parseInt(userMessage, 10);
    if (isNaN(qty) || qty < 0) {
      return getQuantityPrompt({
        name: selectedAddOn.name,
        description: selectedAddOn.description,
        price: selectedAddOn.price,
        isAddon: true,
      });
    }
    if (qty === 0) {
      userStates[userId].state = "add-ons-selection";
      const { menu } = await getAddOnsMenu();
      return menu;
    }
    // Guardar add-on con cantidad
    const addOnWithQty = { ...selectedAddOn, quantity: qty };
    userStates[userId].selectedAddOn = addOnWithQty;
    userStates[userId].state = "confirm-add-on";
    return getAddOnConfirmationPrompt({
      name: selectedAddOn.name,
      price: selectedAddOn.price,
      quantity: qty,
    });
  }

  // Preguntar cantidad para productos frozen-treat sin apiRoute
  if (userStates[userId].state === "ask-frozen-treat-quantity") {
    const availableProducts = userStates[userId].availableProducts;
    const selectedProduct = availableProducts.find(
      (p) => p._id === userStates[userId].selectedProductId
    );
    const qty = parseInt(userMessage, 10);

    if (isNaN(qty) || qty < 0) {
      return getQuantityPrompt({
        name: selectedProduct.name,
        description: selectedProduct.description,
        price: selectedProduct.price,
        isAddon: false,
      });
    }

    if (qty === 0) {
      userStates[userId].state = "menu";
      const { menu, availableProducts: newProducts } = await getMainMenu();
      userStates[userId].availableProducts = newProducts;
      console.log(`[BOT] Transici√≥n a estado: menu (frozen-treat cancelado)`);
      return menu;
    }

    // Agregar producto con cantidad al carrito
    userStates[userId].cart.push({
      name: selectedProduct.name,
      price: selectedProduct.price,
      _id: selectedProduct._id,
      quantity: qty,
      totalPrice: selectedProduct.price * qty,
    });

    userStates[userId].state = "show-product-info";
    console.log(
      `[BOT] Transici√≥n a estado: show-product-info (frozen-treat con cantidad: ${qty})`
    );
    return `${renderCart(
      userStates[userId].cart
    )}\n\n¬øQuieres agregar otro producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
  }

  // Selecci√≥n de sabor de salsa
  if (userStates[userId].state === "sauce-flavour-selection") {
    console.log(
      `[BOT] En estado sauce-flavour-selection, mensaje: '${userMessage}'`
    );
    const availableSauces = userStates[userId].availableSauces;
    console.log(
      `[BOT] Salsas disponibles:`,
      availableSauces ? availableSauces.length : "undefined"
    );

    const option = parseInt(userMessage, 10);
    console.log(
      `[BOT] Opci√≥n parseada: ${option}, rango v√°lido: 1 a ${availableSauces.length}`
    );

    if (isNaN(option) || option < 1 || option > availableSauces.length) {
      const { menu } = await getSauceFlavourMenu();
      console.log(`[BOT] Opci√≥n inv√°lida en sauce-flavour-selection`);
      return `‚ùå Por favor, selecciona una opci√≥n v√°lida.\n\n${menu}`;
    }

    // Usuario eligi√≥ un sabor de salsa
    const selectedSauce = availableSauces[option - 1];
    const selectedAddOn = userStates[userId].selectedAddOn;

    // Guardar add-on con el sabor de salsa seleccionado
    const addOnWithSauce = {
      ...selectedAddOn,
      sauceFlavour: selectedSauce.name,
      displayName: `${selectedAddOn.name} - ${selectedSauce.name}`,
    };
    userStates[userId].selectedAddOn = addOnWithSauce;
    userStates[userId].state = "confirm-add-on";
    console.log(
      `[BOT] Transici√≥n a estado: confirm-add-on (con salsa: ${selectedSauce.name})`
    );
    return getAddOnConfirmationPrompt({
      name: selectedAddOn.name,
      price: selectedAddOn.price,
      sauceFlavour: selectedSauce.name,
    });
  }

  // Confirmaci√≥n de add-on
  if (userStates[userId].state === "confirm-add-on") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      // Guardar add-on confirmado
      if (!userStates[userId].selectedAddOns)
        userStates[userId].selectedAddOns = [];
      userStates[userId].selectedAddOns.push(userStates[userId].selectedAddOn);
      userStates[userId].selectedAddOn = null;
      userStates[userId].state = "add-another-addon";
      console.log(`[BOT] Add-on confirmado, preguntar si quiere otro`);
      return `üç´ *¬øQuieres agregar otro topping o complemento?*\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "add-ons-selection";
      const { menu } = await getAddOnsMenu();
      console.log(
        `[BOT] Transici√≥n a estado: add-ons-selection (add-on no confirmado)`
      );
      return menu;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en confirm-add-on`);
      return `Por favor responde con 1 (s√≠) o 2 (no).\n\n${getAddOnConfirmationPrompt(
        {
          name: userStates[userId].selectedAddOn.name,
          price: userStates[userId].selectedAddOn.price,
          quantity: userStates[userId].selectedAddOn.quantity,
          sauceFlavour: userStates[userId].selectedAddOn.sauceFlavour,
        }
      )}`;
    }
  }

  // Preguntar si quiere otro add-on
  if (userStates[userId].state === "add-another-addon") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      // Mostrar men√∫ de add-ons quitando los ya elegidos
      const { menu, addOns } = await getAddOnsMenu();
      const alreadySelected = userStates[userId].selectedAddOns || [];
      const filteredAddOns = addOns.filter(
        (a) => !alreadySelected.some((sel) => sel._id === a._id)
      );
      userStates[userId].availableAddOns = filteredAddOns;
      userStates[userId].state = "add-ons-selection";
      if (filteredAddOns.length === 0) {
        // No quedan m√°s add-ons
        userStates[userId].state = "show-ice-cream-confirmation";
        return await showIceCreamConfirmation(userId);
      }
      let filteredMenu = `üç´ *¬øQuieres agregar otro topping o complemento?*\n\n`;
      filteredAddOns.forEach((addon, i) => {
        filteredMenu += `${numberToEmoji(
          i + 1
        )} *${addon.name.toUpperCase()}* - $${addon.price}\n`;
      });
      filteredMenu += `\n*No, gracias*\n`;
      filteredMenu += `\nResponde con el n√∫mero de la opci√≥n (1-${filteredAddOns.length}) o escribe *no*`;
      return filteredMenu;
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "show-ice-cream-confirmation";
      return await showIceCreamConfirmation(userId);
    } else {
      return `Por favor responde con 1 (s√≠) o 2 (no).\n\n¬øQuieres agregar otro topping o complemento?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // Despu√©s de mostrar descripci√≥n y precio de un producto (no helado)
  if (userStates[userId].state === "show-product-info") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      // Mostrar men√∫ principal con opci√≥n de cancelar
      userStates[userId].state = "add-another-product-menu";
      const { menu, availableProducts: newProducts } = await getMainMenu({
        allowCancelAddProduct: true,
      });
      userStates[userId].availableProducts = newProducts;
      userStates[userId].lastCart = [...(userStates[userId].cart || [])]; // backup por si cancela
      console.log(`[BOT] Transici√≥n a estado: add-another-product-menu`);
      return menu;
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "delivery-option";
      console.log(
        `[BOT] Transici√≥n a estado: delivery-option (pedido finalizado)`
      );
      return `${renderCart(
        userStates[userId].cart
      )}\n\nüöö *¬øC√≥mo quieres recibir tu pedido?*\n\n1Ô∏è‚É£ üè† *Env√≠o a domicilio*\n2Ô∏è‚É£ üè™ *Retirar en el local*`;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en show-product-info`);
      return `${renderCart(
        userStates[userId].cart
      )}\n\n¬øQuieres agregar otro producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // Nuevo estado para manejar la selecci√≥n en el men√∫ con opci√≥n de cancelar
  if (userStates[userId].state === "add-another-product-menu") {
    const availableProducts = userStates[userId].availableProducts;
    const option = parseInt(userMessage, 10);
    const cancelOption = availableProducts.length + 1;
    if (isNaN(option) || option < 0 || option > cancelOption) {
      const { menu } = await getMainMenu({ allowCancelAddProduct: true });
      return `‚ùå Por favor, selecciona una opci√≥n v√°lida.\n\n${menu}`;
    }
    if (option === 0) {
      usersWithHumanSupport.add(userId);
      userStates[userId] = {
        state: "human_support",
        testMode: userStates[userId].testMode,
      };
      return `üë®‚Äçüíº *Conectando con una persona real...*\n\n‚úÖ *Bot desactivado para esta conversaci√≥n*\n\nUn representante se pondr√° en contacto contigo pronto. Mientras tanto, puedes escribir libremente y ser√°s atendido por una persona real.`;
    }
    if (option === cancelOption) {
      // El usuario cancela agregar otro producto, ir a delivery-option
      userStates[userId].state = "delivery-option";
      userStates[userId].cart =
        userStates[userId].lastCart || userStates[userId].cart;
      delete userStates[userId].lastCart;
      return `${renderCart(
        userStates[userId].cart
      )}\n\nüöö *¬øC√≥mo quieres recibir tu pedido?*\n\n1Ô∏è‚É£ üè† *Env√≠o a domicilio*\n2Ô∏è‚É£ üè™ *Retirar en el local*`;
    }
    // Selecci√≥n de producto normal
    const selectedProduct = availableProducts[option - 1];
    userStates[userId].selectedProductId = selectedProduct._id;
    // Si es frozen-treat, saltar confirmaci√≥n y pedir cantidad directamente
    if (selectedProduct.type === "frozen-treat" && !selectedProduct.apiRoute) {
      userStates[userId].state = "ask-frozen-treat-quantity";
      return getQuantityPrompt({
        name: selectedProduct.name,
        description: selectedProduct.description,
        price: selectedProduct.price,
        isAddon: false,
      });
    }
    // Mostrar confirmaci√≥n del producto para los dem√°s casos
    userStates[userId].state = "confirm-product";
    return `üç∞ *${selectedProduct.name.toUpperCase()}*\n\n$${
      selectedProduct.description ? selectedProduct.description + "\n\n" : ""
    }üí≤Precio: $${
      selectedProduct.price
    }\n\n¬øConfirmas este producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
  }

  // Despu√©s de confirmar sabores de helado
  if (userStates[userId].state === "show-flavour-confirmation") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      // Preservar el carrito y solo cambiar el estado
      userStates[userId].state = "menu";
      const { menu, availableProducts: newProducts } = await getMainMenu();
      userStates[userId].availableProducts = newProducts;
      console.log(
        `[BOT] Transici√≥n a estado: menu (agregar otro producto tras sabores)`
      );
      return menu;
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "delivery-option";
      console.log(
        `[BOT] Transici√≥n a estado: delivery-option (pedido finalizado tras sabores)`
      );
      return `${renderCart(
        userStates[userId].cart
      )}\n\nüöö *¬øC√≥mo quieres recibir tu pedido?*\n\n1Ô∏è‚É£ üè† *Env√≠o a domicilio*\n2Ô∏è‚É£ üè™ *Retirar en el local*`;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en show-flavour-confirmation`);
      return `${renderCart(
        userStates[userId].cart
      )}\n\n¬øQuieres agregar otro producto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // Opci√≥n de entrega
  if (userStates[userId].state === "delivery-option") {
    // Verificar horarios nuevamente antes de procesar la entrega (excepto si est√° en modo test)
    if (!userStates[userId].testMode && !isBusinessHours()) {
      console.log(
        `[BOT] Usuario ${userId} intent√≥ procesar entrega fuera de horario`
      );
      return getOutOfHoursMessage();
    }

    if (
      userMessage === "1" ||
      userMessage === "env√≠o" ||
      userMessage === "domicilio"
    ) {
      userStates[userId].state = "ask-address";
      console.log(`[BOT] Transici√≥n a estado: ask-address`);
      return `üìç *Por favor, env√≠a tu direcci√≥n completa:*\n\nIncluye:\n‚Ä¢ Calle y n√∫mero\n‚Ä¢ Entre calles\n‚Ä¢ Barrio\n\nEjemplo: "Av. Corrientes 1234, entre Callao y Uruguay, Palermo"`;
    } else if (
      userMessage === "2" ||
      userMessage === "retirar" ||
      userMessage === "local"
    ) {
      // Saltar directamente a order-complete y mutear
      userStates[userId].state = "order-complete";
      console.log(`[BOT] Transici√≥n a estado: order-complete (retiro)`);
      return `‚úÖ *¬°Pedido confirmado para retiro!*\n\n${renderCart(
        userStates[userId].cart
      )}\n\nüè™ *Retirar en:*\n${
        userStates[userId].pickupLocation
      }\n\nüí¨ En unos momentos una persona se conectar√° para acordar el m√©todo de pago.`;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en delivery-option`);
      return `‚ùå Por favor, selecciona una opci√≥n v√°lida.\n\nüöö *¬øC√≥mo quieres recibir tu pedido?*\n\n1Ô∏è‚É£ üè† *Env√≠o a domicilio*\n2Ô∏è‚É£ üè™ *Retirar en el local*`;
    }
  }

  // Solicitar direcci√≥n
  if (userStates[userId].state === "ask-address") {
    if (userMessage && userMessage.length > 10) {
      userStates[userId].deliveryAddress = userMessage;
      userStates[userId].state = "address-confirmation";
      console.log(`[BOT] Transici√≥n a estado: address-confirmation`);
      return `üìç *Direcci√≥n confirmada:*\n${userMessage}\n\n${renderCart(
        userStates[userId].cart
      )}\n\n¬øEs correcta la direcci√≥n?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No (escribir de nuevo)`;
    } else {
      console.log(`[BOT] Direcci√≥n muy corta en ask-address`);
      return `‚ùå Por favor, env√≠a una direcci√≥n m√°s completa.\n\nIncluye:\n‚Ä¢ Calle y n√∫mero\n‚Ä¢ Entre calles\n‚Ä¢ Barrio\n\nEjemplo: "Av. Corrientes 1234, entre Callao y Uruguay, Palermo"`;
    }
  }

  // Confirmar direcci√≥n
  if (userStates[userId].state === "address-confirmation") {
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      userStates[userId].state = "order-complete";
      console.log(`[BOT] Transici√≥n a estado: order-complete`);
      return `‚úÖ *¬°Pedido confirmado!*\n\n${renderCart(
        userStates[userId].cart
      )}\n\nüìç *Direcci√≥n de entrega:*\n${
        userStates[userId].deliveryAddress
      }\n\nüí¨ En unos momentos una persona se conectar√° para acordar el m√©todo de pago y costo de env√≠o (seg√∫n la direcci√≥n).`;
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "ask-address";
      console.log(
        `[BOT] Transici√≥n a estado: ask-address (direcci√≥n incorrecta)`
      );
      return `üìç *Por favor, env√≠a tu direcci√≥n completa nuevamente:*\n\nIncluye:\n‚Ä¢ Calle y n√∫mero\n‚Ä¢ Entre calles\n‚Ä¢ Barrio\n\nEjemplo: "Av. Corrientes 1234, entre Callao y Uruguay, Palermo"`;
    } else {
      console.log(`[BOT] Respuesta inv√°lida en address-confirmation`);
      return `‚ùå Por favor, responde con 1 (s√≠) o 2 (no).\n\nüìç *Direcci√≥n confirmada:*\n${userStates[userId].deliveryAddress}\n\n¬øEs correcta la direcci√≥n?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No (escribir de nuevo)`;
    }
  }

  // Pedido completado - solo responder a comandos espec√≠ficos
  if (userStates[userId].state === "order-complete") {
    if (["menu", "hola", "inicio"].includes(userMessage)) {
      // Limpiar carrito y reiniciar estado para nuevo pedido
      userStates[userId] = {
        state: "menu",
        testMode: userStates[userId].testMode,
        cart: [],
      };
      const { menu, availableProducts } = await getMainMenu();
      userStates[userId].availableProducts = availableProducts;
      console.log(
        `[BOT] Transici√≥n a estado: menu (nuevo pedido despu√©s de completar)`
      );
      return menu;
    } else {
      console.log(
        `[BOT] Usuario en estado order-complete, mensaje: '${userMessage}'`
      );
      return; // No responder con mensaje irrelevante
    }
  }

  // Si no hay respuesta v√°lida
  const { menu } = await getMainMenu();
  console.log(
    `[BOT] Comando no reconocido, estado: ${userStates[userId].state}`
  );
  return `‚ùå Comando no reconocido. Escribe "menu" para volver al men√∫ principal.\n\n${menu}`;
}

async function shouldIgnoreMessage(message) {
  const isFromMe = message._data.id.fromMe;
  const targetNumber = "5491130350056@c.us"; // N√∫mero del bot

  const hasImage = message.type === "image";

  // Obtener el chat una sola vez
  let chat;
  try {
    chat = await message.getChat();
  } catch (error) {
    console.log(
      `[CHAT] Error al obtener informaci√≥n del chat: ${error.message}`
    );
    return false; // Si no podemos obtener el chat, continuamos normalmente
  }

  // Check if the chat is archived
  const isArchived = chat.archived;
  // Ignore status updates (WhatsApp Stories)
  const isStory = message.from === "status@broadcast";
  const isSticker = message.type === "sticker";
  const isVoiceMessage = message.type === "ptt";
  console.log("message type is: ");
  console.log(message.type);
  const isTextLess = !message.body || message.body === "";

  //ignore group messages
  const isGroupChat = chat.id.server === "g.us";
  //ignore muted chats
  const isMuted = chat.muteExpiration === -1;
  // Skip empty or "This message can't be displayed here" messages
  const isEmpty = !hasImage && isTextLess && !isVoiceMessage && !isSticker;
  // Ignore messages sent to or received from the target number
  const isIrrelevant =
    message.from === targetNumber || message.to === targetNumber;

  // Ignore messages from users who are talking to a human
  const isUserWithHumanSupport = usersWithHumanSupport.has(message.from);

  const reasonsToIgnoreMessage = [];

  if (isGroupChat) reasonsToIgnoreMessage.push("isGroupChat");
  if (isArchived) reasonsToIgnoreMessage.push("isArchived");
  if (isStory) reasonsToIgnoreMessage.push("isStory");

  /* if (isIrrelevant) reasonsToIgnoreMessage.push("isIrrelevant"); */
  if (isMuted) reasonsToIgnoreMessage.push("isMuted");
  if (isEmpty) reasonsToIgnoreMessage.push("isEmpty");
  if (isUserWithHumanSupport)
    reasonsToIgnoreMessage.push("isUserWithHumanSupport");

  // Solo verificar actividad reciente si no hay otras razones para ignorar
  if (reasonsToIgnoreMessage.length === 0) {
    // --- NUEVA L√ìGICA SIMPLE: DETECTAR MENSAJES DEL ADMIN POR CONTENIDO ---
    try {
      const currentTime = Date.now();
      const sixHoursAgo = currentTime - 6 * 60 * 60 * 1000;

      // Obtener mensajes de las √∫ltimas 6 horas
      const messages = await chat.fetchMessages({ limit: 50 });

      // Filtrar mensajes de las √∫ltimas 6 horas
      const recentMessages = messages.filter((msg) => {
        const msgTime = msg.timestamp * 1000;
        return msgTime > sixHoursAgo;
      });

      console.log(
        `[CHAT] Chat ${message.from} - Revisando ${recentMessages.length} mensajes de las √∫ltimas 6 horas`
      );

      // Verificar si hay alg√∫n mensaje manual del admin en las √∫ltimas 6 horas
      const hasManualMessage = recentMessages.some((msg) => {
        // Solo verificar mensajes del bot
        const isFromBot = msg.from === targetNumber;
        const isFromMe = msg.fromMe;

        if (!isFromBot || !isFromMe) return false;

        // Funci√≥n simple para detectar si es mensaje del bot o del admin
        const isBotMessage = isBotGeneratedMessage(msg.body);

        console.log(
          `[DEBUG] Mensaje: "${msg.body?.substring(
            0,
            50
          )}..." - isFromBot: ${isFromBot}, isFromMe: ${isFromMe}, isBotMessage: ${isBotMessage}, timestamp: ${new Date(
            msg.timestamp * 1000
          ).toLocaleString()}`
        );

        // Si es mensaje del bot pero NO tiene caracter√≠sticas de bot, es manual del admin
        return !isBotMessage;
      });

      if (hasManualMessage) {
        // Encontrar el mensaje espec√≠fico del admin para mostrarlo en el log
        const adminMessage = recentMessages.find((msg) => {
          const isFromBot = msg.from === targetNumber;
          const isFromMe = msg.fromMe;
          if (!isFromBot || !isFromMe) return false;
          return !isBotGeneratedMessage(msg.body);
        });

        console.log(
          `[BOT] Chat ${message.from} tiene mensaje manual del admin en las √∫ltimas 6 horas, desactivando bot autom√°ticamente`
        );
        console.log(
          `[BOT] Mensaje del admin detectado: "${
            adminMessage.body
          }" - ${new Date(adminMessage.timestamp * 1000).toLocaleString()}`
        );
        return true;
      } else {
        console.log(
          `[DEBUG] No se encontraron mensajes manuales del admin en las √∫ltimas 6 horas`
        );
      }
    } catch (error) {
      console.log(
        `[CHAT] Error al procesar historial de mensajes: ${error.message}`
      );
      // Si hay error, continuamos normalmente
    }
  }

  if (reasonsToIgnoreMessage.length > 0) {
    console.log("--------------- START -------------------");
    console.log("return triggered");
    console.log("reason:", reasonsToIgnoreMessage.join(", "));
    console.log("--------------- END -------------------");
    return reasonsToIgnoreMessage.length;
  }
}

// Funci√≥n simple para detectar si un mensaje fue generado por el bot
function isBotGeneratedMessage(messageBody) {
  if (!messageBody || typeof messageBody !== "string") return false;

  const text = messageBody;

  // Contar caracter√≠sticas t√≠picas de mensajes del bot
  // Usar una expresi√≥n regular simple que detecte emojis comunes
  const emojiMatches =
    text.match(
      /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F900}-\u{1F9FF}]|[\u{1F018}-\u{1F270}]|[\u{238C}-\u{2454}]|[\u{20D0}-\u{20FF}]|[\u{FE00}-\u{FE0F}]|[\u{1F1F0}-\u{1F1FF}]|[\u{1F191}-\u{1F251}]|[\u{1F004}]|[\u{1F0CF}]|[\u{1F170}-\u{1F171}]|[\u{1F17E}-\u{1F17F}]|[\u{1F18E}]|[\u{3030}]|[\u{2B50}]|[\u{303D}]|[\u{3297}]|[\u{3299}]|[\u{23}]|[\u{2A}]|[\u{200D}]|[\u{23CF}]|[\u{24C2}]|[\u{1F004}]|[\u{1F0CF}]|[\u{1F170}-\u{1F171}]|[\u{1F17E}-\u{1F17F}]|[\u{1F18E}]|[\u{1F191}-\u{1F19A}]|[\u{1F1E6}-\u{1F1FF}]|[\u{1F201}-\u{1F202}]|[\u{1F21A}]|[\u{1F22F}]|[\u{1F232}-\u{1F23A}]|[\u{1F250}-\u{1F251}]|[\u{1F300}-\u{1F321}]|[\u{1F324}-\u{1F393}]|[\u{1F396}-\u{1F397}]|[\u{1F399}-\u{1F39B}]|[\u{1F39E}-\u{1F3F0}]|[\u{1F3F3}-\u{1F3F5}]|[\u{1F3F7}-\u{1F3FA}]|[\u{1F400}-\u{1F4FD}]|[\u{1F4FF}-\u{1F53D}]|[\u{1F549}-\u{1F54E}]|[\u{1F550}-\u{1F567}]|[\u{1F56F}-\u{1F570}]|[\u{1F573}-\u{1F57A}]|[\u{1F587}]|[\u{1F58A}-\u{1F58D}]|[\u{1F590}]|[\u{1F595}-\u{1F596}]|[\u{1F5A4}-\u{1F5A5}]|[\u{1F5A8}]|[\u{1F5B1}-\u{1F5B2}]|[\u{1F5BC}]|[\u{1F5C2}-\u{1F5C4}]|[\u{1F5D1}-\u{1F5D3}]|[\u{1F5DC}-\u{1F5DE}]|[\u{1F5E1}]|[\u{1F5E3}]|[\u{1F5E8}]|[\u{1F5EF}]|[\u{1F5F3}]|[\u{1F5FA}-\u{1F64F}]|[\u{1F680}-\u{1F6C5}]|[\u{1F6CB}-\u{1F6D2}]|[\u{1F6E0}-\u{1F6E5}]|[\u{1F6E9}]|[\u{1F6EB}-\u{1F6EC}]|[\u{1F6F0}]|[\u{1F6F3}-\u{1F6F9}]|[\u{1F910}-\u{1F93A}]|[\u{1F93C}-\u{1F93E}]|[\u{1F940}-\u{1F945}]|[\u{1F947}-\u{1F970}]|[\u{1F973}-\u{1F976}]|[\u{1F97A}]|[\u{1F97C}-\u{1F9A2}]|[\u{1F9B0}-\u{1F9B9}]|[\u{1F9C0}-\u{1F9C2}]|[\u{1F9D0}-\u{1F9FF}]/gu
    ) || [];
  const emojiCount = emojiMatches.length;
  const newlineCount = (text.match(/\n/g) || []).length;
  const boldCount = (text.match(/\*[^*]+\*/g) || []).length;

  console.log(
    `[DEBUG] isBotGeneratedMessage - Emojis encontrados: [${emojiMatches.join(
      ", "
    )}]`
  );
  console.log(
    `[DEBUG] isBotGeneratedMessage - Emojis: ${emojiCount}, Saltos: ${newlineCount}, Negritas: ${boldCount}`
  );

  // Es mensaje del bot si tiene al menos 2 de estas caracter√≠sticas:
  // - 3 o m√°s emojis
  // - 2 o m√°s saltos de l√≠nea
  // - 2 o m√°s negritas
  const hasManyEmojis = emojiCount >= 3;
  const hasManyNewlines = newlineCount >= 2;
  const hasManyBolds = boldCount >= 2;

  const botCharacteristics = [
    hasManyEmojis,
    hasManyNewlines,
    hasManyBolds,
  ].filter(Boolean).length;

  const isBot = botCharacteristics >= 2;

  console.log(
    `[DEBUG] isBotGeneratedMessage - Resultado: ${isBot} (${botCharacteristics}/3 caracter√≠sticas)`
  );

  return isBot;
}

// Funci√≥n para obtener estad√≠sticas de usuarios
function getBotStats() {
  return {
    totalUsers: Object.keys(userStates).length,
    usersWithHumanSupport: usersWithHumanSupport.size,
    activeBotUsers: Object.keys(userStates).length - usersWithHumanSupport.size,
  };
}

module.exports = {
  shouldIgnoreMessage,
  handleBotMessage,
  getBotStats,
  usersWithHumanSupport,
  isBusinessHours,
  getBusinessHoursMessage,
  getOutOfHoursMessage,
  userStates,
};
