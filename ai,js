const axios = require("axios");

// Estado de conversaci√≥n por usuario
const userStates = {}; // { [userId]: { state: 'menu' | 'product' | 'ice-cream-flavour' | 'human_support', selectedProductId, ... } }

// Usuarios que est√°n hablando con una persona real (bot desactivado)
const usersWithHumanSupport = new Set();

// Helper: number to emoji, usando un emoji por cada d√≠gito
function numberToEmoji(n) {
  const emojiMap = ["0Ô∏è‚É£", "1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£"];
  return n
    .toString()
    .split("")
    .map((digit) => emojiMap[parseInt(digit, 10)])
    .join("");
}

// Funci√≥n para mostrar el men√∫ principal din√°mico
async function getMainMenu() {
  try {
    const { data: products } = await axios.get(
      "http://localhost:3000/products"
    );
    // Filtrar productos disponibles
    const availableProducts = products.filter((p) => !p.outOfStock);
    let menu = `ü§ñ *Bienvenido al Bot*\n\nPor favor, selecciona un producto o una opci√≥n:\n\n`;
    availableProducts.forEach((p, i) => {
      menu += `${numberToEmoji(i + 1)} *${p.name}*\n`;
    });
    menu += `\n${numberToEmoji(
      availableProducts.length + 1
    )} *üí¨ Hablar con una persona real*`;
    menu += `\n${numberToEmoji(availableProducts.length + 2)} *Salir*`;
    menu += `\n\nResponde con el n√∫mero de la opci√≥n (1-${
      availableProducts.length + 2
    })`;
    return { menu, availableProducts };
  } catch (e) {
    return {
      menu: "‚ùå Error al obtener los productos. Intenta m√°s tarde.",
      availableProducts: [],
    };
  }
}

// Funci√≥n para mostrar men√∫ de sabores de helado
async function getFlavourMenu() {
  try {
    const { data: flavours } = await axios.get(
      "http://localhost:3000/generic/flavour"
    );
    const availableFlavours = flavours.filter((f) => !f.outOfStock);
    let menu = `üç¶ *Elige un sabor de helado:*\n\n`;
    availableFlavours.forEach((f, i) => {
      menu += `${numberToEmoji(i + 1)} *${f.name}*\n`;
    });
    menu += `\nResponde con el n√∫mero de la opci√≥n (1-${availableFlavours.length})`;
    return { menu, availableFlavours };
  } catch (e) {
    return {
      menu: "‚ùå Error al obtener los sabores. Intenta m√°s tarde.",
      availableFlavours: [],
    };
  }
}

// Funci√≥n principal para manejar mensajes del bot
async function handleBotMessage(message) {
  const userId = message.from;
  const userMessage = message.body ? message.body.toLowerCase().trim() : "";

  // Inicializar estado del usuario si no existe
  if (!userStates[userId]) {
    userStates[userId] = { state: "menu" };
  }

  // Si el usuario est√° en modo persona real, no responder
  if (usersWithHumanSupport.has(userId)) return;

  // Mostrar men√∫ principal si el usuario escribe "menu", "hola" o "inicio"
  if (["menu", "hola", "inicio"].includes(userMessage)) {
    userStates[userId] = { state: "menu" };
    const { menu, availableProducts } = await getMainMenu();
    userStates[userId].availableProducts = availableProducts;
    return menu;
  }

  // Men√∫ principal din√°mico
  if (userStates[userId].state === "menu") {
    const availableProducts = userStates[userId].availableProducts;
    if (!availableProducts) {
      // Si no hay productos en el estado, volver a mostrar el men√∫
      const { menu, availableProducts: products } = await getMainMenu();
      userStates[userId].availableProducts = products;
      return menu;
    }
    const option = parseInt(userMessage, 10);
    if (isNaN(option) || option < 1 || option > availableProducts.length + 2) {
      const { menu } = await getMainMenu();
      return `‚ùå Por favor, selecciona una opci√≥n v√°lida.\n\n${menu}`;
    }
    // Hablar con persona real
    if (option === availableProducts.length + 1) {
      usersWithHumanSupport.add(userId);
      userStates[userId] = { state: "human_support" };
      return `üë®‚Äçüíº *Conectando con una persona real...*\n\n‚úÖ *Bot desactivado para esta conversaci√≥n*\n\nUn representante se pondr√° en contacto contigo pronto. Mientras tanto, puedes escribir libremente y ser√°s atendido por una persona real.`;
    }
    // Salir
    if (option === availableProducts.length + 2) {
      userStates[userId] = { state: "menu" };
      return `üëã *¬°Hasta luego!*\n\nGracias por usar nuestro bot. ¬°Que tengas un excelente d√≠a!\n\nPara volver a empezar, escribe "hola" o "menu"`;
    }
    // Selecci√≥n de producto
    const selectedProduct = availableProducts[option - 1];
    userStates[userId].selectedProductId = selectedProduct._id;
    // Si es helado, mostrar men√∫ de sabores y guardar cantidad m√°xima
    if (selectedProduct.type === "ice-cream") {
      userStates[userId].state = "ice-cream-flavour";
      userStates[userId].maxFlavours = selectedProduct.flavours || 1;
      const { menu, availableFlavours } = await getFlavourMenu();
      userStates[userId].availableFlavours = availableFlavours;
      return (
        menu +
        `\n\n*Puedes elegir hasta ${userStates[userId].maxFlavours} sabores. Ejemplo: 1 3 5*`
      );
    } else {
      // Mostrar descripci√≥n y precio
      userStates[userId].state = "menu";
      return `üç∞ *${selectedProduct.name}*\n\n${
        selectedProduct.description ? selectedProduct.description + "\n" : ""
      }üí≤Precio: $${selectedProduct.price}`;
    }
  }

  // Men√∫ de sabores de helado (selecci√≥n m√∫ltiple y confirmaci√≥n)
  if (userStates[userId].state === "ice-cream-flavour") {
    const availableFlavours = userStates[userId].availableFlavours;
    const maxFlavours = userStates[userId].maxFlavours || 1;
    // Permitir selecci√≥n m√∫ltiple separada por espacios o comas
    const selectedOptions = userMessage
      .split(/[\,\s]+/)
      .map((x) => parseInt(x, 10))
      .filter((x) => !isNaN(x));
    // Validar cantidad
    if (
      !availableFlavours ||
      selectedOptions.length === 0 ||
      selectedOptions.some(
        (opt) => opt < 1 || opt > availableFlavours.length
      ) ||
      selectedOptions.length > maxFlavours
    ) {
      const { menu } = await getFlavourMenu();
      return `‚ùå Por favor, selecciona hasta ${maxFlavours} sabores v√°lidos.\n\n${menu}\n\n*Ejemplo: 1 3 5*`;
    }
    // Guardar selecci√≥n temporal y pedir confirmaci√≥n
    userStates[userId].pendingFlavours = selectedOptions;
    const selectedFlavours = selectedOptions.map(
      (opt) => availableFlavours[opt - 1].name
    );
    userStates[userId].state = "confirm-flavours";
    return `üç¶ *Los sabores que elegiste son:* ${selectedFlavours.join(
      ", "
    )}\n\n¬øEs correcto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
  }

  // Confirmaci√≥n de sabores
  if (userStates[userId].state === "confirm-flavours") {
    const availableFlavours = userStates[userId].availableFlavours;
    const maxFlavours = userStates[userId].maxFlavours || 1;
    const selectedOptions = userStates[userId].pendingFlavours || [];
    const selectedFlavours = selectedOptions.map(
      (opt) => availableFlavours[opt - 1].name
    );
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      // Si a√∫n puede elegir m√°s sabores
      if (selectedOptions.length < maxFlavours) {
        userStates[userId].state = "add-more-flavour";
        return `A√∫n puedes elegir un sabor m√°s, ¬øquieres hacerlo?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
      } else {
        userStates[userId].state = "menu";
        delete userStates[userId].pendingFlavours;
        return `üç¶ *Sabores confirmados:* ${selectedFlavours.join(
          ", "
        )}\n\n¬øDeseas volver al men√∫ principal? Escribe "menu".`;
      }
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "ice-cream-flavour";
      return await getFlavourMenu().then(
        ({ menu }) =>
          menu +
          `\n\n*Puedes elegir hasta ${maxFlavours} sabores. Ejemplo: 1 3 5*`
      );
    } else {
      return `Por favor responde con 1 (s√≠) o 2 (no).\n\nüç¶ *Los sabores que elegiste son:* ${selectedFlavours.join(
        ", "
      )}\n\n¬øEs correcto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // ¬øAgregar m√°s sabores?
  if (userStates[userId].state === "add-more-flavour") {
    const availableFlavours = userStates[userId].availableFlavours;
    const maxFlavours = userStates[userId].maxFlavours || 1;
    const selectedOptions = userStates[userId].pendingFlavours || [];
    const selectedFlavours = selectedOptions.map(
      (opt) => availableFlavours[opt - 1].name
    );
    if (userMessage === "1" || userMessage === "s√≠" || userMessage === "si") {
      // Mostrar men√∫ de sabores restantes
      const remaining = maxFlavours - selectedOptions.length;
      // Filtrar sabores ya elegidos
      const remainingFlavours = availableFlavours
        .map((f, i) => ({ ...f, idx: i + 1 }))
        .filter((f) => !selectedOptions.includes(f.idx));
      if (remainingFlavours.length === 0) {
        userStates[userId].state = "menu";
        delete userStates[userId].pendingFlavours;
        return `No quedan m√°s sabores disponibles.\n\nüç¶ *Sabores confirmados:* ${selectedFlavours.join(
          ", "
        )}\n\n¬øDeseas volver al men√∫ principal? Escribe "menu".`;
      }
      userStates[userId].state = "add-flavour-selection";
      userStates[userId].remainingFlavours = remainingFlavours;
      userStates[userId].remainingCount = remaining;
      let menu = `üç¶ *Elige ${remaining} sabor(es) m√°s:*\n\n`;
      remainingFlavours.forEach((f, i) => {
        menu += `${numberToEmoji(i + 1)} *${f.name}*\n`;
      });
      menu += `\nResponde con el n√∫mero de la opci√≥n.`;
      return menu;
    } else if (userMessage === "2" || userMessage === "no") {
      userStates[userId].state = "menu";
      delete userStates[userId].pendingFlavours;
      return `üç¶ *Sabores confirmados:* ${selectedFlavours.join(
        ", "
      )}\n\n¬øDeseas volver al men√∫ principal? Escribe "menu".`;
    } else {
      return `Por favor responde con 1 (s√≠) o 2 (no).\n\nA√∫n puedes elegir un sabor m√°s, ¬øquieres hacerlo?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
    }
  }

  // Selecci√≥n de sabor adicional
  if (userStates[userId].state === "add-flavour-selection") {
    const remainingFlavours = userStates[userId].remainingFlavours || [];
    const remainingCount = userStates[userId].remainingCount || 1;
    const selectedOptions = userStates[userId].pendingFlavours || [];
    // Permitir solo selecci√≥n de uno
    const opt = parseInt(userMessage, 10);
    if (isNaN(opt) || opt < 1 || opt > remainingFlavours.length) {
      let menu = `‚ùå Selecci√≥n inv√°lida.\n\nüç¶ *Elige ${remainingCount} sabor(es) m√°s:*\n\n`;
      remainingFlavours.forEach((f, i) => {
        menu += `${numberToEmoji(i + 1)} *${f.name}*\n`;
      });
      menu += `\nResponde con el n√∫mero de la opci√≥n.`;
      return menu;
    }
    // Agregar el nuevo sabor
    const newFlavourIdx = remainingFlavours[opt - 1].idx;
    selectedOptions.push(newFlavourIdx);
    userStates[userId].pendingFlavours = selectedOptions;
    // Volver a pedir confirmaci√≥n
    const allFlavours = userStates[userId].availableFlavours;
    const selectedFlavours = selectedOptions.map(
      (idx) => allFlavours[idx - 1].name
    );
    userStates[userId].state = "confirm-flavours";
    return `üç¶ *Los sabores que elegiste son:* ${selectedFlavours.join(
      ", "
    )}\n\n¬øEs correcto?\n1Ô∏è‚É£ S√≠\n2Ô∏è‚É£ No`;
  }

  // Si no hay respuesta v√°lida
  const { menu } = await getMainMenu();
  return `‚ùå Comando no reconocido. Escribe "menu" para volver al men√∫ principal.\n\n${menu}`;
}

async function shouldIgnoreMessage(message) {
  let name;
  let log;
  const isFromMe = message._data.id.fromMe;
  const targetNumber = "5491130350056@c.us"; // The number you don't want to forward messages to/from

  const hasImage = message.type === "image";

  const chat = await message.getChat();
  // Check if the chat is archived
  const isArchived = chat.archived;
  // Ignore status updates (WhatsApp Stories)
  const isStory = message.from === "status@broadcast";
  const isSticker = message.type === "sticker";
  const isVoiceMessage = message.type === "ptt";
  console.log("message type is: ");
  console.log(message.type);
  const isTextLess = !message.body || message.body === "";

  //ignore group messages
  const isGroupChat = chat.id.server === "g.us";
  //ignore muted chats
  const isMuted = chat.muteExpiration === -1;
  // Skip empty or "This message can't be displayed here" messages
  const isEmpty = !hasImage && isTextLess && !isVoiceMessage && !isSticker;
  // Ignore messages sent to or received from the target number
  const isIrrelevant =
    message.from === targetNumber || message.to === targetNumber;

  // Ignore messages from users who are talking to a human
  const isUserWithHumanSupport = usersWithHumanSupport.has(message.from);

  const reasonsToIgnoreMessage = [];

  if (isGroupChat) reasonsToIgnoreMessage.push("isGroupChat");
  if (isArchived) reasonsToIgnoreMessage.push("isArchived");
  if (isStory) reasonsToIgnoreMessage.push("isStory");

  /* if (isIrrelevant) reasonsToIgnoreMessage.push("isIrrelevant"); */
  if (isMuted) reasonsToIgnoreMessage.push("isMuted");
  if (isEmpty) reasonsToIgnoreMessage.push("isEmpty");
  if (isUserWithHumanSupport)
    reasonsToIgnoreMessage.push("isUserWithHumanSupport");

  if (reasonsToIgnoreMessage.length > 0) {
    console.log("--------------- START -------------------");
    console.log("return triggered");
    console.log("reason:", reasonsToIgnoreMessage.join(", "));
    console.log("--------------- END -------------------");
    return reasonsToIgnoreMessage.length;
  }
}

// Funci√≥n para obtener estad√≠sticas de usuarios
function getBotStats() {
  return {
    totalUsers: Object.keys(userStates).length,
    usersWithHumanSupport: usersWithHumanSupport.size,
    activeBotUsers: Object.keys(userStates).length - usersWithHumanSupport.size,
  };
}

module.exports = {
  shouldIgnoreMessage,
  handleBotMessage,
  getBotStats,
  usersWithHumanSupport,
};
